/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 4);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n!function ($) {\n  \"use strict\";\n\n  var FOUNDATION_VERSION = '6.2.4'; // Global Foundation object\n  // This is attached to the window, or used as a module for AMD/Browserify\n\n  var Foundation = {\n    version: FOUNDATION_VERSION,\n\n    /**\n     * Stores initialized plugins.\n     */\n    _plugins: {},\n\n    /**\n     * Stores generated unique ids for plugin instances\n     */\n    _uuids: [],\n\n    /**\n     * Returns a boolean for RTL support\n     */\n    rtl: function rtl() {\n      return $('html').attr('dir') === 'rtl';\n    },\n\n    /**\n     * Defines a Foundation plugin, adding it to the `Foundation` namespace and the list of plugins to initialize when reflowing.\n     * @param {Object} plugin - The constructor of the plugin.\n     */\n    plugin: function plugin(_plugin, name) {\n      // Object key to use when adding to global Foundation object\n      // Examples: Foundation.Reveal, Foundation.OffCanvas\n      var className = name || functionName(_plugin); // Object key to use when storing the plugin, also used to create the identifying data attribute for the plugin\n      // Examples: data-reveal, data-off-canvas\n\n      var attrName = hyphenate(className); // Add to the Foundation object and the plugins list (for reflowing)\n\n      this._plugins[attrName] = this[className] = _plugin;\n    },\n\n    /**\n     * @function\n     * Populates the _uuids array with pointers to each individual plugin instance.\n     * Adds the `zfPlugin` data-attribute to programmatically created plugins to allow use of $(selector).foundation(method) calls.\n     * Also fires the initialization event for each plugin, consolidating repetitive code.\n     * @param {Object} plugin - an instance of a plugin, usually `this` in context.\n     * @param {String} name - the name of the plugin, passed as a camelCased string.\n     * @fires Plugin#init\n     */\n    registerPlugin: function registerPlugin(plugin, name) {\n      var pluginName = name ? hyphenate(name) : functionName(plugin.constructor).toLowerCase();\n      plugin.uuid = this.GetYoDigits(6, pluginName);\n\n      if (!plugin.$element.attr(\"data-\".concat(pluginName))) {\n        plugin.$element.attr(\"data-\".concat(pluginName), plugin.uuid);\n      }\n\n      if (!plugin.$element.data('zfPlugin')) {\n        plugin.$element.data('zfPlugin', plugin);\n      }\n      /**\n       * Fires when the plugin has initialized.\n       * @event Plugin#init\n       */\n\n\n      plugin.$element.trigger(\"init.zf.\".concat(pluginName));\n\n      this._uuids.push(plugin.uuid);\n\n      return;\n    },\n\n    /**\n     * @function\n     * Removes the plugins uuid from the _uuids array.\n     * Removes the zfPlugin data attribute, as well as the data-plugin-name attribute.\n     * Also fires the destroyed event for the plugin, consolidating repetitive code.\n     * @param {Object} plugin - an instance of a plugin, usually `this` in context.\n     * @fires Plugin#destroyed\n     */\n    unregisterPlugin: function unregisterPlugin(plugin) {\n      var pluginName = hyphenate(functionName(plugin.$element.data('zfPlugin').constructor));\n\n      this._uuids.splice(this._uuids.indexOf(plugin.uuid), 1);\n\n      plugin.$element.removeAttr(\"data-\".concat(pluginName)).removeData('zfPlugin')\n      /**\n       * Fires when the plugin has been destroyed.\n       * @event Plugin#destroyed\n       */\n      .trigger(\"destroyed.zf.\".concat(pluginName));\n\n      for (var prop in plugin) {\n        plugin[prop] = null; //clean up script to prep for garbage collection.\n      }\n\n      return;\n    },\n\n    /**\n     * @function\n     * Causes one or more active plugins to re-initialize, resetting event listeners, recalculating positions, etc.\n     * @param {String} plugins - optional string of an individual plugin key, attained by calling `$(element).data('pluginName')`, or string of a plugin class i.e. `'dropdown'`\n     * @default If no argument is passed, reflow all currently active plugins.\n     */\n    reInit: function reInit(plugins) {\n      var isJQ = plugins instanceof $;\n\n      try {\n        if (isJQ) {\n          plugins.each(function () {\n            $(this).data('zfPlugin')._init();\n          });\n        } else {\n          var type = _typeof(plugins),\n              _this = this,\n              fns = {\n            'object': function object(plgs) {\n              plgs.forEach(function (p) {\n                p = hyphenate(p);\n                $('[data-' + p + ']').foundation('_init');\n              });\n            },\n            'string': function string() {\n              plugins = hyphenate(plugins);\n              $('[data-' + plugins + ']').foundation('_init');\n            },\n            'undefined': function undefined() {\n              this['object'](Object.keys(_this._plugins));\n            }\n          };\n\n          fns[type](plugins);\n        }\n      } catch (err) {\n        console.error(err);\n      } finally {\n        return plugins;\n      }\n    },\n\n    /**\n     * returns a random base-36 uid with namespacing\n     * @function\n     * @param {Number} length - number of random base-36 digits desired. Increase for more random strings.\n     * @param {String} namespace - name of plugin to be incorporated in uid, optional.\n     * @default {String} '' - if no plugin name is provided, nothing is appended to the uid.\n     * @returns {String} - unique id\n     */\n    GetYoDigits: function GetYoDigits(length, namespace) {\n      length = length || 6;\n      return Math.round(Math.pow(36, length + 1) - Math.random() * Math.pow(36, length)).toString(36).slice(1) + (namespace ? \"-\".concat(namespace) : '');\n    },\n\n    /**\n     * Initialize plugins on any elements within `elem` (and `elem` itself) that aren't already initialized.\n     * @param {Object} elem - jQuery object containing the element to check inside. Also checks the element itself, unless it's the `document` object.\n     * @param {String|Array} plugins - A list of plugins to initialize. Leave this out to initialize everything.\n     */\n    reflow: function reflow(elem, plugins) {\n      // If plugins is undefined, just grab everything\n      if (typeof plugins === 'undefined') {\n        plugins = Object.keys(this._plugins);\n      } // If plugins is a string, convert it to an array with one item\n      else if (typeof plugins === 'string') {\n          plugins = [plugins];\n        }\n\n      var _this = this; // Iterate through each plugin\n\n\n      $.each(plugins, function (i, name) {\n        // Get the current plugin\n        var plugin = _this._plugins[name]; // Localize the search to all elements inside elem, as well as elem itself, unless elem === document\n\n        var $elem = $(elem).find('[data-' + name + ']').addBack('[data-' + name + ']'); // For each plugin found, initialize it\n\n        $elem.each(function () {\n          var $el = $(this),\n              opts = {}; // Don't double-dip on plugins\n\n          if ($el.data('zfPlugin')) {\n            console.warn(\"Tried to initialize \" + name + \" on an element that already has a Foundation plugin.\");\n            return;\n          }\n\n          if ($el.attr('data-options')) {\n            var thing = $el.attr('data-options').split(';').forEach(function (e, i) {\n              var opt = e.split(':').map(function (el) {\n                return el.trim();\n              });\n              if (opt[0]) opts[opt[0]] = parseValue(opt[1]);\n            });\n          }\n\n          try {\n            $el.data('zfPlugin', new plugin($(this), opts));\n          } catch (er) {\n            console.error(er);\n          } finally {\n            return;\n          }\n        });\n      });\n    },\n    getFnName: functionName,\n    transitionend: function transitionend($elem) {\n      var transitions = {\n        'transition': 'transitionend',\n        'WebkitTransition': 'webkitTransitionEnd',\n        'MozTransition': 'transitionend',\n        'OTransition': 'otransitionend'\n      };\n      var elem = document.createElement('div'),\n          end;\n\n      for (var t in transitions) {\n        if (typeof elem.style[t] !== 'undefined') {\n          end = transitions[t];\n        }\n      }\n\n      if (end) {\n        return end;\n      } else {\n        end = setTimeout(function () {\n          $elem.triggerHandler('transitionend', [$elem]);\n        }, 1);\n        return 'transitionend';\n      }\n    }\n  };\n  Foundation.util = {\n    /**\n     * Function for applying a debounce effect to a function call.\n     * @function\n     * @param {Function} func - Function to be called at end of timeout.\n     * @param {Number} delay - Time in ms to delay the call of `func`.\n     * @returns function\n     */\n    throttle: function throttle(func, delay) {\n      var timer = null;\n      return function () {\n        var context = this,\n            args = arguments;\n\n        if (timer === null) {\n          timer = setTimeout(function () {\n            func.apply(context, args);\n            timer = null;\n          }, delay);\n        }\n      };\n    }\n  }; // TODO: consider not making this a jQuery function\n  // TODO: need way to reflow vs. re-initialize\n\n  /**\n   * The Foundation jQuery method.\n   * @param {String|Array} method - An action to perform on the current jQuery object.\n   */\n\n  var foundation = function foundation(method) {\n    var type = _typeof(method),\n        $meta = $('meta.foundation-mq'),\n        $noJS = $('.no-js');\n\n    if (!$meta.length) {\n      $('<meta class=\"foundation-mq\">').appendTo(document.head);\n    }\n\n    if ($noJS.length) {\n      $noJS.removeClass('no-js');\n    }\n\n    if (type === 'undefined') {\n      //needs to initialize the Foundation object, or an individual plugin.\n      Foundation.MediaQuery._init();\n\n      Foundation.reflow(this);\n    } else if (type === 'string') {\n      //an individual method to invoke on a plugin or group of plugins\n      var args = Array.prototype.slice.call(arguments, 1); //collect all the arguments, if necessary\n\n      var plugClass = this.data('zfPlugin'); //determine the class of plugin\n\n      if (plugClass !== undefined && plugClass[method] !== undefined) {\n        //make sure both the class and method exist\n        if (this.length === 1) {\n          //if there's only one, call it directly.\n          plugClass[method].apply(plugClass, args);\n        } else {\n          this.each(function (i, el) {\n            //otherwise loop through the jQuery collection and invoke the method on each\n            plugClass[method].apply($(el).data('zfPlugin'), args);\n          });\n        }\n      } else {\n        //error for no class or no method\n        throw new ReferenceError(\"We're sorry, '\" + method + \"' is not an available method for \" + (plugClass ? functionName(plugClass) : 'this element') + '.');\n      }\n    } else {\n      //error for invalid argument type\n      throw new TypeError(\"We're sorry, \".concat(type, \" is not a valid parameter. You must use a string representing the method you wish to invoke.\"));\n    }\n\n    return this;\n  };\n\n  window.Foundation = Foundation;\n  $.fn.foundation = foundation; // Polyfill for requestAnimationFrame\n\n  (function () {\n    if (!Date.now || !window.Date.now) window.Date.now = Date.now = function () {\n      return new Date().getTime();\n    };\n    var vendors = ['webkit', 'moz'];\n\n    for (var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {\n      var vp = vendors[i];\n      window.requestAnimationFrame = window[vp + 'RequestAnimationFrame'];\n      window.cancelAnimationFrame = window[vp + 'CancelAnimationFrame'] || window[vp + 'CancelRequestAnimationFrame'];\n    }\n\n    if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) || !window.requestAnimationFrame || !window.cancelAnimationFrame) {\n      var lastTime = 0;\n\n      window.requestAnimationFrame = function (callback) {\n        var now = Date.now();\n        var nextTime = Math.max(lastTime + 16, now);\n        return setTimeout(function () {\n          callback(lastTime = nextTime);\n        }, nextTime - now);\n      };\n\n      window.cancelAnimationFrame = clearTimeout;\n    }\n    /**\n     * Polyfill for performance.now, required by rAF\n     */\n\n\n    if (!window.performance || !window.performance.now) {\n      window.performance = {\n        start: Date.now(),\n        now: function now() {\n          return Date.now() - this.start;\n        }\n      };\n    }\n  })();\n\n  if (!Function.prototype.bind) {\n    Function.prototype.bind = function (oThis) {\n      if (typeof this !== 'function') {\n        // closest thing possible to the ECMAScript 5\n        // internal IsCallable function\n        throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n      }\n\n      var aArgs = Array.prototype.slice.call(arguments, 1),\n          fToBind = this,\n          fNOP = function fNOP() {},\n          fBound = function fBound() {\n        return fToBind.apply(this instanceof fNOP ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));\n      };\n\n      if (this.prototype) {\n        // native functions don't have a prototype\n        fNOP.prototype = this.prototype;\n      }\n\n      fBound.prototype = new fNOP();\n      return fBound;\n    };\n  } // Polyfill to get the name of a function in IE9\n\n\n  function functionName(fn) {\n    if (Function.prototype.name === undefined) {\n      var funcNameRegex = /function\\s([^(]{1,})\\(/;\n      var results = funcNameRegex.exec(fn.toString());\n      return results && results.length > 1 ? results[1].trim() : \"\";\n    } else if (fn.prototype === undefined) {\n      return fn.constructor.name;\n    } else {\n      return fn.prototype.constructor.name;\n    }\n  }\n\n  function parseValue(str) {\n    if (/true/.test(str)) return true;else if (/false/.test(str)) return false;else if (!isNaN(str * 1)) return parseFloat(str);\n    return str;\n  } // Convert PascalCase to kebab-case\n  // Thank you: http://stackoverflow.com/a/8955580\n\n\n  function hyphenate(str) {\n    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n  }\n}(jQuery);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2ZvdW5kYXRpb24tc2l0ZXMvanMvZm91bmRhdGlvbi5jb3JlLmpzP2U0NTMiXSwibmFtZXMiOlsiJCIsIkZPVU5EQVRJT05fVkVSU0lPTiIsIkZvdW5kYXRpb24iLCJ2ZXJzaW9uIiwiX3BsdWdpbnMiLCJfdXVpZHMiLCJydGwiLCJhdHRyIiwicGx1Z2luIiwibmFtZSIsImNsYXNzTmFtZSIsImZ1bmN0aW9uTmFtZSIsImF0dHJOYW1lIiwiaHlwaGVuYXRlIiwicmVnaXN0ZXJQbHVnaW4iLCJwbHVnaW5OYW1lIiwiY29uc3RydWN0b3IiLCJ0b0xvd2VyQ2FzZSIsInV1aWQiLCJHZXRZb0RpZ2l0cyIsIiRlbGVtZW50IiwiZGF0YSIsInRyaWdnZXIiLCJwdXNoIiwidW5yZWdpc3RlclBsdWdpbiIsInNwbGljZSIsImluZGV4T2YiLCJyZW1vdmVBdHRyIiwicmVtb3ZlRGF0YSIsInByb3AiLCJyZUluaXQiLCJwbHVnaW5zIiwiaXNKUSIsImVhY2giLCJfaW5pdCIsInR5cGUiLCJfdGhpcyIsImZucyIsInBsZ3MiLCJmb3JFYWNoIiwicCIsImZvdW5kYXRpb24iLCJPYmplY3QiLCJrZXlzIiwiZXJyIiwiY29uc29sZSIsImVycm9yIiwibGVuZ3RoIiwibmFtZXNwYWNlIiwiTWF0aCIsInJvdW5kIiwicG93IiwicmFuZG9tIiwidG9TdHJpbmciLCJzbGljZSIsInJlZmxvdyIsImVsZW0iLCJpIiwiJGVsZW0iLCJmaW5kIiwiYWRkQmFjayIsIiRlbCIsIm9wdHMiLCJ3YXJuIiwidGhpbmciLCJzcGxpdCIsImUiLCJvcHQiLCJtYXAiLCJlbCIsInRyaW0iLCJwYXJzZVZhbHVlIiwiZXIiLCJnZXRGbk5hbWUiLCJ0cmFuc2l0aW9uZW5kIiwidHJhbnNpdGlvbnMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJlbmQiLCJ0Iiwic3R5bGUiLCJzZXRUaW1lb3V0IiwidHJpZ2dlckhhbmRsZXIiLCJ1dGlsIiwidGhyb3R0bGUiLCJmdW5jIiwiZGVsYXkiLCJ0aW1lciIsImNvbnRleHQiLCJhcmdzIiwiYXJndW1lbnRzIiwiYXBwbHkiLCJtZXRob2QiLCIkbWV0YSIsIiRub0pTIiwiYXBwZW5kVG8iLCJoZWFkIiwicmVtb3ZlQ2xhc3MiLCJNZWRpYVF1ZXJ5IiwiQXJyYXkiLCJwcm90b3R5cGUiLCJjYWxsIiwicGx1Z0NsYXNzIiwidW5kZWZpbmVkIiwiUmVmZXJlbmNlRXJyb3IiLCJUeXBlRXJyb3IiLCJ3aW5kb3ciLCJmbiIsIkRhdGUiLCJub3ciLCJnZXRUaW1lIiwidmVuZG9ycyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInZwIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJ0ZXN0IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwibGFzdFRpbWUiLCJjYWxsYmFjayIsIm5leHRUaW1lIiwibWF4IiwiY2xlYXJUaW1lb3V0IiwicGVyZm9ybWFuY2UiLCJzdGFydCIsIkZ1bmN0aW9uIiwiYmluZCIsIm9UaGlzIiwiYUFyZ3MiLCJmVG9CaW5kIiwiZk5PUCIsImZCb3VuZCIsImNvbmNhdCIsImZ1bmNOYW1lUmVnZXgiLCJyZXN1bHRzIiwiZXhlYyIsInN0ciIsImlzTmFOIiwicGFyc2VGbG9hdCIsInJlcGxhY2UiLCJqUXVlcnkiXSwibWFwcGluZ3MiOiI7O0FBQUEsQ0FBQyxVQUFTQSxDQUFULEVBQVk7QUFFYjs7QUFFQSxNQUFJQyxrQkFBa0IsR0FBRyxPQUF6QixDQUphLENBTWI7QUFDQTs7QUFDQSxNQUFJQyxVQUFVLEdBQUc7QUFDZkMsV0FBTyxFQUFFRixrQkFETTs7QUFHZjs7O0FBR0FHLFlBQVEsRUFBRSxFQU5LOztBQVFmOzs7QUFHQUMsVUFBTSxFQUFFLEVBWE87O0FBYWY7OztBQUdBQyxPQUFHLEVBQUUsZUFBVTtBQUNiLGFBQU9OLENBQUMsQ0FBQyxNQUFELENBQUQsQ0FBVU8sSUFBVixDQUFlLEtBQWYsTUFBMEIsS0FBakM7QUFDRCxLQWxCYzs7QUFtQmY7Ozs7QUFJQUMsVUFBTSxFQUFFLGdC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LEdBQWtDdUYsT0FBTyxDQUFDLENBQUQsQ0FBUCxDQUFXaEUsSUFBWCxFQUFsQyxHQUFzRCxFQUE3RDtBQUNELEtBSkQsTUFLSyxJQUFJcUMsRUFBRSxDQUFDUCxTQUFILEtBQWlCRyxTQUFyQixFQUFnQztBQUNuQyxhQUFPSSxFQUFFLENBQUMzRixXQUFILENBQWVQLElBQXRCO0FBQ0QsS0FGSSxNQUdBO0FBQ0gsYUFBT2tHLEVBQUUsQ0FBQ1AsU0FBSCxDQUFhcEYsV0FBYixDQUF5QlAsSUFBaEM7QUFDRDtBQUNGOztBQUNELFdBQVM4RCxVQUFULENBQW9CaUUsR0FBcEIsRUFBd0I7QUFDdEIsUUFBRyxPQUFPckIsSUFBUCxDQUFZcUIsR0FBWixDQUFILEVBQXFCLE9BQU8sSUFBUCxDQUFyQixLQUNLLElBQUcsUUFBUXJCLElBQVIsQ0FBYXFCLEdBQWIsQ0FBSCxFQUFzQixPQUFPLEtBQVAsQ0FBdEIsS0FDQSxJQUFHLENBQUNDLEtBQUssQ0FBQ0QsR0FBRyxHQUFHLENBQVAsQ0FBVCxFQUFvQixPQUFPRSxVQUFVLENBQUNGLEdBQUQsQ0FBakI7QUFDekIsV0FBT0EsR0FBUDtBQUNELEdBbFhZLENBbVhiO0FBQ0E7OztBQUNBLFdBQVMzSCxTQUFULENBQW1CMkgsR0FBbkIsRUFBd0I7QUFDdEIsV0FBT0EsR0FBRyxDQUFDRyxPQUFKLENBQVksaUJBQVosRUFBK0IsT0FBL0IsRUFBd0MxSCxXQUF4QyxFQUFQO0FBQ0Q7QUFFQSxDQXpYQSxDQXlYQzJILE1BelhELENBQUQiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIiFmdW5jdGlvbigkKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRk9VTkRBVElPTl9WRVJTSU9OID0gJzYuMi40JztcblxuLy8gR2xvYmFsIEZvdW5kYXRpb24gb2JqZWN0XG4vLyBUaGlzIGlzIGF0dGFjaGVkIHRvIHRoZSB3aW5kb3csIG9yIHVzZWQgYXMgYSBtb2R1bGUgZm9yIEFNRC9Ccm93c2VyaWZ5XG52YXIgRm91bmRhdGlvbiA9IHtcbiAgdmVyc2lvbjogRk9VTkRBVElPTl9WRVJTSU9OLFxuXG4gIC8qKlxuICAgKiBTdG9yZXMgaW5pdGlhbGl6ZWQgcGx1Z2lucy5cbiAgICovXG4gIF9wbHVnaW5zOiB7fSxcblxuICAvKipcbiAgICogU3RvcmVzIGdlbmVyYXRlZCB1bmlxdWUgaWRzIGZvciBwbHVnaW4gaW5zdGFuY2VzXG4gICAqL1xuICBfdXVpZHM6IFtdLFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBmb3IgUlRMIHN1cHBvcnRcbiAgICovXG4gIHJ0bDogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gJCgnaHRtbCcpLmF0dHIoJ2RpcicpID09PSAncnRsJztcbiAgfSxcbiAgLyoqXG4gICAqIERlZmluZXMgYSBGb3VuZGF0aW9uIHBsdWdpbiwgYWRkaW5nIGl0IHRvIHRoZSBgRm91bmRhdGlvbmAgbmFtZXNwYWNlIGFuZCB0aGUgbGlzdCBvZiBwbHVnaW5zIHRvIGluaXRpYWxpemUgd2hlbiByZWZsb3dpbmcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwbHVnaW4gLSBUaGUgY29uc3RydWN0b3Igb2YgdGhlIHBsdWdpbi5cbiAgICovXG4gIHBsdWdpbjogZnVuY3Rpb24ocGx1Z2luLCBuYW1lKSB7XG4gICAgLy8gT2JqZWN0IGtleSB0byB1c2Ugd2hlbiBhZGRpbmcgdG8gZ2xvYmFsIEZvdW5kYXRpb24gb2JqZWN0XG4gICAgLy8gRXhhbXBsZXM6IEZvdW5kYXRpb24uUmV2ZWFsLCBGb3VuZGF0aW9uLk9mZkNhbnZhc1xuICAgIHZhciBjbGFzc05hbWUgPSAobmFtZSB8fCBmdW5jdGlvbk5hbWUocGx1Z2luKSk7XG4gICAgLy8gT2JqZWN0IGtleSB0byB1c2Ugd2hlbiBzdG9yaW5nIHRoZSBwbHVnaW4sIGFsc28gdXNlZCB0byBjcmVhdGUgdGhlIGlkZW50aWZ5aW5nIGRhdGEgYXR0cmlidXRlIGZvciB0aGUgcGx1Z2luXG4gICAgLy8gRXhhbXBsZXM6IGRhdGEtcmV2ZWFsLCBkYXRhLW9mZi1jYW52YXNcbiAgICB2YXIgYXR0ck5hbWUgID0gaHlwaGVuYXRlKGNsYXNzTmFtZSk7XG5cbiAgICAvLyBBZGQgdG8gdGhlIEZvdW5kYXRpb24gb2JqZWN0IGFuZCB0aGUgcGx1Z2lucyBsaXN0IChmb3IgcmVmbG93aW5nKVxuICAgIHRoaXMuX3BsdWdpbnNbYXR0ck5hbWVdID0gdGhpc1tjbGFzc05hbWVdID0gcGx1Z2luO1xuICB9LFxuICAvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqIFBvcHVsYXRlcyB0aGUgX3V1aWRzIGFycmF5IHdpdGggcG9pbnRlcnMgdG8gZWFjaCBpbmRpdmlkdWFsIHBsdWdpbiBpbnN0YW5jZS5cbiAgICogQWRkcyB0aGUgYHpmUGx1Z2luYCBkYXRhLWF0dHJpYnV0ZSB0byBwcm9ncmFtbWF0aWNhbGx5IGNyZWF0ZWQgcGx1Z2lucyB0byBhbGxvdyB1c2Ugb2YgJChzZWxlY3RvcikuZm91bmRhdGlvbihtZXRob2QpIGNhbGxzLlxuICAgKiBBbHNvIGZpcmVzIHRoZSBpbml0aWFsaXphdGlvbiBldmVudCBmb3IgZWFjaCBwbHVnaW4sIGNvbnNvbGlkYXRpbmcgcmVwZXRpdGl2ZSBjb2RlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGx1Z2luIC0gYW4gaW5zdGFuY2Ugb2YgYSBwbHVnaW4sIHVzdWFsbHkgYHRoaXNgIGluIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIHBsdWdpbiwgcGFzc2VkIGFzIGEgY2FtZWxDYXNlZCBzdHJpbmcuXG4gICAqIEBmaXJlcyBQbHVnaW4jaW5pdFxuICAgKi9cbiAgcmVnaXN0ZXJQbHVnaW46IGZ1bmN0aW9uKHBsdWdpbiwgbmFtZSl7XG4gICAgdmFyIHBsdWdpbk5hbWUgPSBuYW1lID8gaHlwaGVuYXRlKG5hbWUpIDogZnVuY3Rpb25OYW1lKHBsdWdpbi5jb25zdHJ1Y3RvcikudG9Mb3dlckNhc2UoKTtcbiAgICBwbHVnaW4udXVpZCA9IHRoaXMuR2V0WW9EaWdpdHMoNiwgcGx1Z2luTmFtZSk7XG5cbiAgICBpZighcGx1Z2luLiRlbGVtZW50LmF0dHIoYGRhdGEtJHtwbHVnaW5OYW1lfWApKXsgcGx1Z2luLiRlbGVtZW50LmF0dHIoYGRhdGEtJHtwbHVnaW5OYW1lfWAsIHBsdWdpbi51dWlkKTsgfVxuICAgIGlmKCFwbHVnaW4uJGVsZW1lbnQuZGF0YSgnemZQbHVnaW4nKSl7IHBsdWdpbi4kZWxlbWVudC5kYXRhKCd6ZlBsdWdpbicsIHBsdWdpbik7IH1cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBwbHVnaW4gaGFzIGluaXRpYWxpemVkLlxuICAgICAgICAgICAqIEBldmVudCBQbHVnaW4jaW5pdFxuICAgICAgICAgICAqL1xuICAgIHBsdWdpbi4kZWxlbWVudC50cmlnZ2VyKGBpbml0LnpmLiR7cGx1Z2luTmFtZX1gKTtcblxuICAgIHRoaXMuX3V1aWRzLnB1c2gocGx1Z2luLnV1aWQpO1xuXG4gICAgcmV0dXJuO1xuICB9LFxuICAvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqIFJlbW92ZXMgdGhlIHBsdWdpbnMgdXVpZCBmcm9tIHRoZSBfdXVpZHMgYXJyYXkuXG4gICAqIFJlbW92ZXMgdGhlIHpmUGx1Z2luIGRhdGEgYXR0cmlidXRlLCBhcyB3ZWxsIGFzIHRoZSBkYXRhLXBsdWdpbi1uYW1lIGF0dHJpYnV0ZS5cbiAgICogQWxzbyBmaXJlcyB0aGUgZGVzdHJveWVkIGV2ZW50IGZvciB0aGUgcGx1Z2luLCBjb25zb2xpZGF0aW5nIHJlcGV0aXRpdmUgY29kZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBsdWdpbiAtIGFuIGluc3RhbmNlIG9mIGEgcGx1Z2luLCB1c3VhbGx5IGB0aGlzYCBpbiBjb250ZXh0LlxuICAgKiBAZmlyZXMgUGx1Z2luI2Rlc3Ryb3llZFxuICAgKi9cbiAgdW5yZWdpc3RlclBsdWdpbjogZnVuY3Rpb24ocGx1Z2luKXtcbiAgICB2YXIgcGx1Z2luTmFtZSA9IGh5cGhlbmF0ZShmdW5jdGlvbk5hbWUocGx1Z2luLiRlbGVtZW50LmRhdGEoJ3pmUGx1Z2luJykuY29uc3RydWN0b3IpKTtcblxuICAgIHRoaXMuX3V1aWRzLnNwbGljZSh0aGlzLl91dWlkcy5pbmRleE9mKHBsdWdpbi51dWlkKSwgMSk7XG4gICAgcGx1Z2luLiRlbGVtZW50LnJlbW92ZUF0dHIoYGRhdGEtJHtwbHVnaW5OYW1lfWApLnJlbW92ZURhdGEoJ3pmUGx1Z2luJylcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBwbHVnaW4gaGFzIGJlZW4gZGVzdHJveWVkLlxuICAgICAgICAgICAqIEBldmVudCBQbHVnaW4jZGVzdHJveWVkXG4gICAgICAgICAgICovXG4gICAgICAgICAgLnRyaWdnZXIoYGRlc3Ryb3llZC56Zi4ke3BsdWdpbk5hbWV9YCk7XG4gICAgZm9yKHZhciBwcm9wIGluIHBsdWdpbil7XG4gICAgICBwbHVnaW5bcHJvcF0gPSBudWxsOy8vY2xlYW4gdXAgc2NyaXB0IHRvIHByZXAgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbi5cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQ2F1c2VzIG9uZSBvciBtb3JlIGFjdGl2ZSBwbHVnaW5zIHRvIHJlLWluaXRpYWxpemUsIHJlc2V0dGluZyBldmVudCBsaXN0ZW5lcnMsIHJlY2FsY3VsYXRpbmcgcG9zaXRpb25zLCBldGMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwbHVnaW5zIC0gb3B0aW9uYWwgc3RyaW5nIG9mIGFuIGluZGl2aWR1YWwgcGx1Z2luIGtleSwgYXR0YWluZWQgYnkgY2FsbGluZyBgJChlbGVtZW50KS5kYXRhKCdwbHVnaW5OYW1lJylgLCBvciBzdHJpbmcgb2YgYSBwbHVnaW4gY2xhc3MgaS5lLiBgJ2Ryb3Bkb3duJ2BcbiAgICogQGRlZmF1bHQgSWYgbm8gYXJndW1lbnQgaXMgcGFzc2VkLCByZWZsb3cgYWxsIGN1cnJlbnRseSBhY3RpdmUgcGx1Z2lucy5cbiAgICovXG4gICByZUluaXQ6IGZ1bmN0aW9uKHBsdWdpbnMpe1xuICAgICB2YXIgaXNKUSA9IHBsdWdpbnMgaW5zdGFuY2VvZiAkO1xuICAgICB0cnl7XG4gICAgICAgaWYoaXNKUSl7XG4gICAgICAgICBwbHVnaW5zLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgICAgICAgJCh0aGlzKS5kYXRhKCd6ZlBsdWdpbicpLl9pbml0KCk7XG4gICAgICAgICB9KTtcbiAgICAgICB9ZWxzZXtcbiAgICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHBsdWdpbnMsXG4gICAgICAgICBfdGhpcyA9IHRoaXMsXG4gICAgICAgICBmbnMgPSB7XG4gICAgICAgICAgICdvYmplY3QnOiBmdW5jdGlvbihwbGdzKXtcbiAgICAgICAgICAgICBwbGdzLmZvckVhY2goZnVuY3Rpb24ocCl7XG4gICAgICAgICAgICAgICBwID0gaHlwaGVuYXRlKHApO1xuICAgICAgICAgICAgICAgJCgnW2RhdGEtJysgcCArJ10nKS5mb3VuZGF0aW9uKCdfaW5pdCcpO1xuICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICB9LFxuICAgICAgICAgICAnc3RyaW5nJzogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICBwbHVnaW5zID0gaHlwaGVuYXRlKHBsdWdpbnMpO1xuICAgICAgICAgICAgICQoJ1tkYXRhLScrIHBsdWdpbnMgKyddJykuZm91bmRhdGlvbignX2luaXQnKTtcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgJ3VuZGVmaW5lZCc6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgdGhpc1snb2JqZWN0J10oT2JqZWN0LmtleXMoX3RoaXMuX3BsdWdpbnMpKTtcbiAgICAgICAgICAgfVxuICAgICAgICAgfTtcbiAgICAgICAgIGZuc1t0eXBlXShwbHVnaW5zKTtcbiAgICAgICB9XG4gICAgIH1jYXRjaChlcnIpe1xuICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgfWZpbmFsbHl7XG4gICAgICAgcmV0dXJuIHBsdWdpbnM7XG4gICAgIH1cbiAgIH0sXG5cbiAgLyoqXG4gICAqIHJldHVybnMgYSByYW5kb20gYmFzZS0zNiB1aWQgd2l0aCBuYW1lc3BhY2luZ1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCAtIG51bWJlciBvZiByYW5kb20gYmFzZS0zNiBkaWdpdHMgZGVzaXJlZC4gSW5jcmVhc2UgZm9yIG1vcmUgcmFuZG9tIHN0cmluZ3MuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgLSBuYW1lIG9mIHBsdWdpbiB0byBiZSBpbmNvcnBvcmF0ZWQgaW4gdWlkLCBvcHRpb25hbC5cbiAgICogQGRlZmF1bHQge1N0cmluZ30gJycgLSBpZiBubyBwbHVnaW4gbmFtZSBpcyBwcm92aWRlZCwgbm90aGluZyBpcyBhcHBlbmRlZCB0byB0aGUgdWlkLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSAtIHVuaXF1ZSBpZFxuICAgKi9cbiAgR2V0WW9EaWdpdHM6IGZ1bmN0aW9uKGxlbmd0aCwgbmFtZXNwYWNlKXtcbiAgICBsZW5ndGggPSBsZW5ndGggfHwgNjtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCgoTWF0aC5wb3coMzYsIGxlbmd0aCArIDEpIC0gTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDM2LCBsZW5ndGgpKSkudG9TdHJpbmcoMzYpLnNsaWNlKDEpICsgKG5hbWVzcGFjZSA/IGAtJHtuYW1lc3BhY2V9YCA6ICcnKTtcbiAgfSxcbiAgLyoqXG4gICAqIEluaXRpYWxpemUgcGx1Z2lucyBvbiBhbnkgZWxlbWVudHMgd2l0aGluIGBlbGVtYCAoYW5kIGBlbGVtYCBpdHNlbGYpIHRoYXQgYXJlbid0IGFscmVhZHkgaW5pdGlhbGl6ZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtIC0galF1ZXJ5IG9iamVjdCBjb250YWluaW5nIHRoZSBlbGVtZW50IHRvIGNoZWNrIGluc2lkZS4gQWxzbyBjaGVja3MgdGhlIGVsZW1lbnQgaXRzZWxmLCB1bmxlc3MgaXQncyB0aGUgYGRvY3VtZW50YCBvYmplY3QuXG4gICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBwbHVnaW5zIC0gQSBsaXN0IG9mIHBsdWdpbnMgdG8gaW5pdGlhbGl6ZS4gTGVhdmUgdGhpcyBvdXQgdG8gaW5pdGlhbGl6ZSBldmVyeXRoaW5nLlxuICAgKi9cbiAgcmVmbG93OiBmdW5jdGlvbihlbGVtLCBwbHVnaW5zKSB7XG5cbiAgICAvLyBJZiBwbHVnaW5zIGlzIHVuZGVmaW5lZCwganVzdCBncmFiIGV2ZXJ5dGhpbmdcbiAgICBpZiAodHlwZW9mIHBsdWdpbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBwbHVnaW5zID0gT2JqZWN0LmtleXModGhpcy5fcGx1Z2lucyk7XG4gICAgfVxuICAgIC8vIElmIHBsdWdpbnMgaXMgYSBzdHJpbmcsIGNvbnZlcnQgaXQgdG8gYW4gYXJyYXkgd2l0aCBvbmUgaXRlbVxuICAgIGVsc2UgaWYgKHR5cGVvZiBwbHVnaW5zID09PSAnc3RyaW5nJykge1xuICAgICAgcGx1Z2lucyA9IFtwbHVnaW5zXTtcbiAgICB9XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGVhY2ggcGx1Z2luXG4gICAgJC5lYWNoKHBsdWdpbnMsIGZ1bmN0aW9uKGksIG5hbWUpIHtcbiAgICAgIC8vIEdldCB0aGUgY3VycmVudCBwbHVnaW5cbiAgICAgIHZhciBwbHVnaW4gPSBfdGhpcy5fcGx1Z2luc1tuYW1lXTtcblxuICAgICAgLy8gTG9jYWxpemUgdGhlIHNlYXJjaCB0byBhbGwgZWxlbWVudHMgaW5zaWRlIGVsZW0sIGFzIHdlbGwgYXMgZWxlbSBpdHNlbGYsIHVubGVzcyBlbGVtID09PSBkb2N1bWVudFxuICAgICAgdmFyICRlbGVtID0gJChlbGVtKS5maW5kKCdbZGF0YS0nK25hbWUrJ10nKS5hZGRCYWNrKCdbZGF0YS0nK25hbWUrJ10nKTtcblxuICAgICAgLy8gRm9yIGVhY2ggcGx1Z2luIGZvdW5kLCBpbml0aWFsaXplIGl0XG4gICAgICAkZWxlbS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgJGVsID0gJCh0aGlzKSxcbiAgICAgICAgICAgIG9wdHMgPSB7fTtcbiAgICAgICAgLy8gRG9uJ3QgZG91YmxlLWRpcCBvbiBwbHVnaW5zXG4gICAgICAgIGlmICgkZWwuZGF0YSgnemZQbHVnaW4nKSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIlRyaWVkIHRvIGluaXRpYWxpemUgXCIrbmFtZStcIiBvbiBhbiBlbGVtZW50IHRoYXQgYWxyZWFkeSBoYXMgYSBGb3VuZGF0aW9uIHBsdWdpbi5cIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoJGVsLmF0dHIoJ2RhdGEtb3B0aW9ucycpKXtcbiAgICAgICAgICB2YXIgdGhpbmcgPSAkZWwuYXR0cignZGF0YS1vcHRpb25zJykuc3BsaXQoJzsnKS5mb3JFYWNoKGZ1bmN0aW9uKGUsIGkpe1xuICAgICAgICAgICAgdmFyIG9wdCA9IGUuc3BsaXQoJzonKS5tYXAoZnVuY3Rpb24oZWwpeyByZXR1cm4gZWwudHJpbSgpOyB9KTtcbiAgICAgICAgICAgIGlmKG9wdFswXSkgb3B0c1tvcHRbMF1dID0gcGFyc2VWYWx1ZShvcHRbMV0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRyeXtcbiAgICAgICAgICAkZWwuZGF0YSgnemZQbHVnaW4nLCBuZXcgcGx1Z2luKCQodGhpcyksIG9wdHMpKTtcbiAgICAgICAgfWNhdGNoKGVyKXtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGVyKTtcbiAgICAgICAgfWZpbmFsbHl7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSxcbiAgZ2V0Rm5OYW1lOiBmdW5jdGlvbk5hbWUsXG4gIHRyYW5zaXRpb25lbmQ6IGZ1bmN0aW9uKCRlbGVtKXtcbiAgICB2YXIgdHJhbnNpdGlvbnMgPSB7XG4gICAgICAndHJhbnNpdGlvbic6ICd0cmFuc2l0aW9uZW5kJyxcbiAgICAgICdXZWJraXRUcmFuc2l0aW9uJzogJ3dlYmtpdFRyYW5zaXRpb25FbmQnLFxuICAgICAgJ01velRyYW5zaXRpb24nOiAndHJhbnNpdGlvbmVuZCcsXG4gICAgICAnT1RyYW5zaXRpb24nOiAnb3RyYW5zaXRpb25lbmQnXG4gICAgfTtcbiAgICB2YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICBlbmQ7XG5cbiAgICBmb3IgKHZhciB0IGluIHRyYW5zaXRpb25zKXtcbiAgICAgIGlmICh0eXBlb2YgZWxlbS5zdHlsZVt0XSAhPT0gJ3VuZGVmaW5lZCcpe1xuICAgICAgICBlbmQgPSB0cmFuc2l0aW9uc1t0XTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYoZW5kKXtcbiAgICAgIHJldHVybiBlbmQ7XG4gICAgfWVsc2V7XG4gICAgICBlbmQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICRlbGVtLnRyaWdnZXJIYW5kbGVyKCd0cmFuc2l0aW9uZW5kJywgWyRlbGVtXSk7XG4gICAgICB9LCAxKTtcbiAgICAgIHJldHVybiAndHJhbnNpdGlvbmVuZCc7XG4gICAgfVxuICB9XG59O1xuXG5Gb3VuZGF0aW9uLnV0aWwgPSB7XG4gIC8qKlxuICAgKiBGdW5jdGlvbiBmb3IgYXBwbHlpbmcgYSBkZWJvdW5jZSBlZmZlY3QgdG8gYSBmdW5jdGlvbiBjYWxsLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyAtIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBhdCBlbmQgb2YgdGltZW91dC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5IC0gVGltZSBpbiBtcyB0byBkZWxheSB0aGUgY2FsbCBvZiBgZnVuY2AuXG4gICAqIEByZXR1cm5zIGZ1bmN0aW9uXG4gICAqL1xuICB0aHJvdHRsZTogZnVuY3Rpb24gKGZ1bmMsIGRlbGF5KSB7XG4gICAgdmFyIHRpbWVyID0gbnVsbDtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICAgIGlmICh0aW1lciA9PT0gbnVsbCkge1xuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcblxuLy8gVE9ETzogY29uc2lkZXIgbm90IG1ha2luZyB0aGlzIGEgalF1ZXJ5IGZ1bmN0aW9uXG4vLyBUT0RPOiBuZWVkIHdheSB0byByZWZsb3cgdnMuIHJlLWluaXRpYWxpemVcbi8qKlxuICogVGhlIEZvdW5kYXRpb24galF1ZXJ5IG1ldGhvZC5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBtZXRob2QgLSBBbiBhY3Rpb24gdG8gcGVyZm9ybSBvbiB0aGUgY3VycmVudCBqUXVlcnkgb2JqZWN0LlxuICovXG52YXIgZm91bmRhdGlvbiA9IGZ1bmN0aW9uKG1ldGhvZCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBtZXRob2QsXG4gICAgICAkbWV0YSA9ICQoJ21ldGEuZm91bmRhdGlvbi1tcScpLFxuICAgICAgJG5vSlMgPSAkKCcubm8tanMnKTtcblxuICBpZighJG1ldGEubGVuZ3RoKXtcbiAgICAkKCc8bWV0YSBjbGFzcz1cImZvdW5kYXRpb24tbXFcIj4nKS5hcHBlbmRUbyhkb2N1bWVudC5oZWFkKTtcbiAgfVxuICBpZigkbm9KUy5sZW5ndGgpe1xuICAgICRub0pTLnJlbW92ZUNsYXNzKCduby1qcycpO1xuICB9XG5cbiAgaWYodHlwZSA9PT0gJ3VuZGVmaW5lZCcpey8vbmVlZHMgdG8gaW5pdGlhbGl6ZSB0aGUgRm91bmRhdGlvbiBvYmplY3QsIG9yIGFuIGluZGl2aWR1YWwgcGx1Z2luLlxuICAgIEZvdW5kYXRpb24uTWVkaWFRdWVyeS5faW5pdCgpO1xuICAgIEZvdW5kYXRpb24ucmVmbG93KHRoaXMpO1xuICB9ZWxzZSBpZih0eXBlID09PSAnc3RyaW5nJyl7Ly9hbiBpbmRpdmlkdWFsIG1ldGhvZCB0byBpbnZva2Ugb24gYSBwbHVnaW4gb3IgZ3JvdXAgb2YgcGx1Z2luc1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsvL2NvbGxlY3QgYWxsIHRoZSBhcmd1bWVudHMsIGlmIG5lY2Vzc2FyeVxuICAgIHZhciBwbHVnQ2xhc3MgPSB0aGlzLmRhdGEoJ3pmUGx1Z2luJyk7Ly9kZXRlcm1pbmUgdGhlIGNsYXNzIG9mIHBsdWdpblxuXG4gICAgaWYocGx1Z0NsYXNzICE9PSB1bmRlZmluZWQgJiYgcGx1Z0NsYXNzW21ldGhvZF0gIT09IHVuZGVmaW5lZCl7Ly9tYWtlIHN1cmUgYm90aCB0aGUgY2xhc3MgYW5kIG1ldGhvZCBleGlzdFxuICAgICAgaWYodGhpcy5sZW5ndGggPT09IDEpey8vaWYgdGhlcmUncyBvbmx5IG9uZSwgY2FsbCBpdCBkaXJlY3RseS5cbiAgICAgICAgICBwbHVnQ2xhc3NbbWV0aG9kXS5hcHBseShwbHVnQ2xhc3MsIGFyZ3MpO1xuICAgICAgfWVsc2V7XG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihpLCBlbCl7Ly9vdGhlcndpc2UgbG9vcCB0aHJvdWdoIHRoZSBqUXVlcnkgY29sbGVjdGlvbiBhbmQgaW52b2tlIHRoZSBtZXRob2Qgb24gZWFjaFxuICAgICAgICAgIHBsdWdDbGFzc1ttZXRob2RdLmFwcGx5KCQoZWwpLmRhdGEoJ3pmUGx1Z2luJyksIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9ZWxzZXsvL2Vycm9yIGZvciBubyBjbGFzcyBvciBubyBtZXRob2RcbiAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcIldlJ3JlIHNvcnJ5LCAnXCIgKyBtZXRob2QgKyBcIicgaXMgbm90IGFuIGF2YWlsYWJsZSBtZXRob2QgZm9yIFwiICsgKHBsdWdDbGFzcyA/IGZ1bmN0aW9uTmFtZShwbHVnQ2xhc3MpIDogJ3RoaXMgZWxlbWVudCcpICsgJy4nKTtcbiAgICB9XG4gIH1lbHNley8vZXJyb3IgZm9yIGludmFsaWQgYXJndW1lbnQgdHlwZVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFdlJ3JlIHNvcnJ5LCAke3R5cGV9IGlzIG5vdCBhIHZhbGlkIHBhcmFtZXRlci4gWW91IG11c3QgdXNlIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgbWV0aG9kIHlvdSB3aXNoIHRvIGludm9rZS5gKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbndpbmRvdy5Gb3VuZGF0aW9uID0gRm91bmRhdGlvbjtcbiQuZm4uZm91bmRhdGlvbiA9IGZvdW5kYXRpb247XG5cbi8vIFBvbHlmaWxsIGZvciByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbihmdW5jdGlvbigpIHtcbiAgaWYgKCFEYXRlLm5vdyB8fCAhd2luZG93LkRhdGUubm93KVxuICAgIHdpbmRvdy5EYXRlLm5vdyA9IERhdGUubm93ID0gZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTsgfTtcblxuICB2YXIgdmVuZG9ycyA9IFsnd2Via2l0JywgJ21veiddO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvcnMubGVuZ3RoICYmICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK2kpIHtcbiAgICAgIHZhciB2cCA9IHZlbmRvcnNbaV07XG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93W3ZwKydSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9ICh3aW5kb3dbdnArJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJ11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHdpbmRvd1t2cCsnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ10pO1xuICB9XG4gIGlmICgvaVAoYWR8aG9uZXxvZCkuKk9TIDYvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpXG4gICAgfHwgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgIXdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSkge1xuICAgIHZhciBsYXN0VGltZSA9IDA7XG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgbmV4dFRpbWUgPSBNYXRoLm1heChsYXN0VGltZSArIDE2LCBub3cpO1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHsgY2FsbGJhY2sobGFzdFRpbWUgPSBuZXh0VGltZSk7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRUaW1lIC0gbm93KTtcbiAgICB9O1xuICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGNsZWFyVGltZW91dDtcbiAgfVxuICAvKipcbiAgICogUG9seWZpbGwgZm9yIHBlcmZvcm1hbmNlLm5vdywgcmVxdWlyZWQgYnkgckFGXG4gICAqL1xuICBpZighd2luZG93LnBlcmZvcm1hbmNlIHx8ICF3aW5kb3cucGVyZm9ybWFuY2Uubm93KXtcbiAgICB3aW5kb3cucGVyZm9ybWFuY2UgPSB7XG4gICAgICBzdGFydDogRGF0ZS5ub3coKSxcbiAgICAgIG5vdzogZnVuY3Rpb24oKXsgcmV0dXJuIERhdGUubm93KCkgLSB0aGlzLnN0YXJ0OyB9XG4gICAgfTtcbiAgfVxufSkoKTtcbmlmICghRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQpIHtcbiAgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihvVGhpcykge1xuICAgIGlmICh0eXBlb2YgdGhpcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gY2xvc2VzdCB0aGluZyBwb3NzaWJsZSB0byB0aGUgRUNNQVNjcmlwdCA1XG4gICAgICAvLyBpbnRlcm5hbCBJc0NhbGxhYmxlIGZ1bmN0aW9uXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCAtIHdoYXQgaXMgdHJ5aW5nIHRvIGJlIGJvdW5kIGlzIG5vdCBjYWxsYWJsZScpO1xuICAgIH1cblxuICAgIHZhciBhQXJncyAgID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcbiAgICAgICAgZlRvQmluZCA9IHRoaXMsXG4gICAgICAgIGZOT1AgICAgPSBmdW5jdGlvbigpIHt9LFxuICAgICAgICBmQm91bmQgID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGZUb0JpbmQuYXBwbHkodGhpcyBpbnN0YW5jZW9mIGZOT1BcbiAgICAgICAgICAgICAgICAgPyB0aGlzXG4gICAgICAgICAgICAgICAgIDogb1RoaXMsXG4gICAgICAgICAgICAgICAgIGFBcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICAgIH07XG5cbiAgICBpZiAodGhpcy5wcm90b3R5cGUpIHtcbiAgICAgIC8vIG5hdGl2ZSBmdW5jdGlvbnMgZG9uJ3QgaGF2ZSBhIHByb3RvdHlwZVxuICAgICAgZk5PUC5wcm90b3R5cGUgPSB0aGlzLnByb3RvdHlwZTtcbiAgICB9XG4gICAgZkJvdW5kLnByb3RvdHlwZSA9IG5ldyBmTk9QKCk7XG5cbiAgICByZXR1cm4gZkJvdW5kO1xuICB9O1xufVxuLy8gUG9seWZpbGwgdG8gZ2V0IHRoZSBuYW1lIG9mIGEgZnVuY3Rpb24gaW4gSUU5XG5mdW5jdGlvbiBmdW5jdGlvbk5hbWUoZm4pIHtcbiAgaWYgKEZ1bmN0aW9uLnByb3RvdHlwZS5uYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZnVuY05hbWVSZWdleCA9IC9mdW5jdGlvblxccyhbXihdezEsfSlcXCgvO1xuICAgIHZhciByZXN1bHRzID0gKGZ1bmNOYW1lUmVnZXgpLmV4ZWMoKGZuKS50b1N0cmluZygpKTtcbiAgICByZXR1cm4gKHJlc3VsdHMgJiYgcmVzdWx0cy5sZW5ndGggPiAxKSA/IHJlc3VsdHNbMV0udHJpbSgpIDogXCJcIjtcbiAgfVxuICBlbHNlIGlmIChmbi5wcm90b3R5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmbi5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBmbi5wcm90b3R5cGUuY29uc3RydWN0b3IubmFtZTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VWYWx1ZShzdHIpe1xuICBpZigvdHJ1ZS8udGVzdChzdHIpKSByZXR1cm4gdHJ1ZTtcbiAgZWxzZSBpZigvZmFsc2UvLnRlc3Qoc3RyKSkgcmV0dXJuIGZhbHNlO1xuICBlbHNlIGlmKCFpc05hTihzdHIgKiAxKSkgcmV0dXJuIHBhcnNlRmxvYXQoc3RyKTtcbiAgcmV0dXJuIHN0cjtcbn1cbi8vIENvbnZlcnQgUGFzY2FsQ2FzZSB0byBrZWJhYi1jYXNlXG4vLyBUaGFuayB5b3U6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzg5NTU1ODBcbmZ1bmN0aW9uIGh5cGhlbmF0ZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpO1xufVxuXG59KGpRdWVyeSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2ZvdW5kYXRpb24tc2l0ZXMvanMvZm91bmRhdGlvbi5jb3JlLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n!function ($) {\n  /**\n   * ResponsiveToggle module.\n   * @module foundation.responsiveToggle\n   * @requires foundation.util.mediaQuery\n   */\n  var ResponsiveToggle =\n  /*#__PURE__*/\n  function () {\n    /**\n     * Creates a new instance of Tab Bar.\n     * @class\n     * @fires ResponsiveToggle#init\n     * @param {jQuery} element - jQuery object to attach tab bar functionality to.\n     * @param {Object} options - Overrides to the default plugin settings.\n     */\n    function ResponsiveToggle(element, options) {\n      _classCallCheck(this, ResponsiveToggle);\n\n      this.$element = $(element);\n      this.options = $.extend({}, ResponsiveToggle.defaults, this.$element.data(), options);\n\n      this._init();\n\n      this._events();\n\n      Foundation.registerPlugin(this, 'ResponsiveToggle');\n    }\n    /**\n     * Initializes the tab bar by finding the target element, toggling element, and running update().\n     * @function\n     * @private\n     */\n\n\n    _createClass(ResponsiveToggle, [{\n      key: \"_init\",\n      value: function _init() {\n        var targetID = this.$element.data('responsive-toggle');\n\n        if (!targetID) {\n          console.error('Your tab bar needs an ID of a Menu as the value of data-tab-bar.');\n        }\n\n        this.$targetMenu = $(\"#\".concat(targetID));\n        this.$toggler = this.$element.find('[data-toggle]');\n\n        this._update();\n      }\n      /**\n       * Adds necessary event handlers for the tab bar to work.\n       * @function\n       * @private\n       */\n\n    }, {\n      key: \"_events\",\n      value: function _events() {\n        var _this = this;\n\n        this._updateMqHandler = this._update.bind(this);\n        $(window).on('changed.zf.mediaquery', this._updateMqHandler);\n        this.$toggler.on('click.zf.responsiveToggle', this.toggleMenu.bind(this));\n      }\n      /**\n       * Checks the current media query to determine if the tab bar should be visible or hidden.\n       * @function\n       * @private\n       */\n\n    }, {\n      key: \"_update\",\n      value: function _update() {\n        // Mobile\n        if (!Foundation.MediaQuery.atLeast(this.options.hideFor)) {\n          this.$element.show();\n          this.$targetMenu.hide();\n        } // Desktop\n        else {\n            this.$element.hide();\n            this.$targetMenu.show();\n          }\n      }\n      /**\n       * Toggles the element attached to the tab bar. The toggle only happens if the screen is small enough to allow it.\n       * @function\n       * @fires ResponsiveToggle#toggled\n       */\n\n    }, {\n      key: \"toggleMenu\",\n      value: function toggleMenu() {\n        if (!Foundation.MediaQuery.atLeast(this.options.hideFor)) {\n          this.$targetMenu.toggle(0);\n          /**\n           * Fires when the element attached to the tab bar toggles.\n           * @event ResponsiveToggle#toggled\n           */\n\n          this.$element.trigger('toggled.zf.responsiveToggle');\n        }\n      }\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        this.$element.off('.zf.responsiveToggle');\n        this.$toggler.off('.zf.responsiveToggle');\n        $(window).off('changed.zf.mediaquery', this._updateMqHandler);\n        Foundation.unregisterPlugin(this);\n      }\n    }]);\n\n    return ResponsiveToggle;\n  }();\n\n  ResponsiveToggle.defaults = {\n    /**\n     * The breakpoint after which the menu is always shown, and the tab bar is hidden.\n     * @option\n     * @example 'medium'\n     */\n    hideFor: 'medium'\n  }; // Window exports\n\n  Foundation.plugin(ResponsiveToggle, 'ResponsiveToggle');\n}(jQuery);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2ZvdW5kYXRpb24tc2l0ZXMvanMvZm91bmRhdGlvbi5yZXNwb25zaXZlVG9nZ2xlLmpzP2MyNzciXSwibmFtZXMiOlsiJCIsIlJlc3BvbnNpdmVUb2dnbGUiLCJlbGVtZW50Iiwib3B0aW9ucyIsIiRlbGVtZW50IiwiZXh0ZW5kIiwiZGVmYXVsdHMiLCJkYXRhIiwiX2luaXQiLCJfZXZlbnRzIiwiRm91bmRhdGlvbiIsInJlZ2lzdGVyUGx1Z2luIiwidGFyZ2V0SUQiLCJjb25zb2xlIiwiZXJyb3IiLCIkdGFyZ2V0TWVudSIsIiR0b2dnbGVyIiwiZmluZCIsIl91cGRhdGUiLCJfdGhpcyIsIl91cGRhdGVNcUhhbmRsZXIiLCJiaW5kIiwid2luZG93Iiwib24iLCJ0b2dnbGVNZW51IiwiTWVkaWFRdWVyeSIsImF0TGVhc3QiLCJoaWRlRm9yIiwic2hvdyIsImhpZGUiLCJ0b2dnbGUiLCJ0cmlnZ2VyIiwib2ZmIiwidW5yZWdpc3RlclBsdWdpbiIsInBsdWdpbiIsImpRdWVyeSJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0FBRUEsQ0FBQyxVQUFTQSxDQUFULEVBQVk7QUFFYjs7Ozs7QUFGYSxNQVFQQyxnQkFSTztBQUFBO0FBQUE7QUFTWDs7Ozs7OztBQU9BLDhCQUFZQyxPQUFaLEVBQXFCQyxPQUFyQixFQUE4QjtBQUFBOztBQUM1QixXQUFLQyxRQUFMLEdBQWdCSixDQUFDLENBQUNFLE9BQUQsQ0FBakI7QUFDQSxXQUFLQyxPQUFMLEdBQWVILENBQUMsQ0FBQ0ssTUFBRixDQUFTLEVBQVQsRUFBYUosZ0JBQWdCLENBQUNLLFFBQTlCLEVBQXdDLEtBQUtGLFFBQUwsQ0FBY0csSUFBZCxFQUF4QyxFQUE4REosT0FBOUQsQ0FBZjs7QUFFQSxXQUFLSyxLQUFMOztBQUNBLFdBQUtDLE9BQUw7O0FBRUFDLGdCQUFVLENBQUNDLGNBQVgsQ0FBMEIsSUFBMUIsRUFBZ0Msa0JBQWhDO0FBQ0Q7QUFFRDs7Ozs7OztBQTFCVztBQUFBO0FBQUEsOEJBK0JIO0FBQ04sWUFBSUMsUUFBUSxHQUFHLEtBQUtSLFFBQUwsQ0FBY0csSUFBZCxDQUFtQixtQkFBbkIsQ0FBZjs7QUFDQSxZQUFJLENBQUNLLFFBQUwsRUFBZTtBQUNiQyxpQkFBTyxDQUFDQyxLQUFSLENBQWMsa0VBQWQ7QUFDRDs7QUFFRCxhQUFLQyxXQUFMLEdBQW1CZixDQUFDLFlBQUtZLFFBQUwsRUFBcEI7QUFDQSxhQUFLSSxRQUFMLEdBQWdCLEtBQUtaLFFBQUwsQ0FBY2EsSUFBZCxDQUFtQixlQUFuQixDQUFoQjs7QUFFQSxhQUFLQyxPQUFMO0FBQ0Q7QUFFRDs7Ozs7O0FBM0NXO0FBQUE7QUFBQSxnQ0FnREQ7QUFDUixZQUFJQyxLQUFLLEdBQUcsSUFBWjs7QUFFQSxhQUFLQyxnQkFBTCxHQUF3QixLQUFLRixPQUFMLENBQWFHLElBQWIsQ0FBa0IsSUFBbEIsQ0FBeEI7QUFFQXJCLFNBQUMsQ0FBQ3NCLE1BQUQsQ0FBRCxDQUFVQyxFQUFWLENBQWEsdUJBQWIsRUFBc0MsS0FBS0gsZ0JBQTNDO0FBRUEsYUFBS0osUUFBTCxDQUFjTyxFQUFkLENBQWlCLDJCQUFqQixFQUE4QyxLQUFLQyxVQUFMLENBQWdCSCxJQUFoQixDQUFxQixJQUFyQixDQUE5QztBQUNEO0FBRUQ7Ozs7OztBQTFEVztBQUFBO0FBQUEsZ0NBK0REO0FBQ1I7QUFDQSxZQUFJLENBQUNYLFVBQVUsQ0FBQ2UsVUFBWCxDQUFzQkMsT0FBdEIsQ0FBOEIsS0FBS3ZCLE9BQUwsQ0FBYXdCLE9BQTNDLENBQUwsRUFBMEQ7QUFDeEQsZUFBS3ZCLFFBQUwsQ0FBY3dCLElBQWQ7QUFDQSxlQUFLYixXQUFMLENBQWlCYyxJQUFqQjtBQUNELFNBSEQsQ0FLQTtBQUxBLGFBTUs7QUFDSCxpQkFBS3pCLFFBQUwsQ0FBY3lCLElBQWQ7QUFDQSxpQkFBS2QsV0FBTCxDQUFpQmEsSUFBakI7QUFDRDtBQUNGO0FBRUQ7Ozs7OztBQTdFVztBQUFBO0FBQUEsbUNBa0ZFO0FBQ1gsWUFBSSxDQUFDbEIsVUFBVSxDQUFDZSxVQUFYLENBQXNCQyxPQUF0QixDQUE4QixLQUFLdkIsT0FBTCxDQUFhd0IsT0FBM0MsQ0FBTCxFQUEwRDtBQUN4RCxlQUFLWixXQUFMLENBQWlCZSxNQUFqQixDQUF3QixDQUF4QjtBQUVBOzs7OztBQUlBLGVBQUsxQixRQUFMLENBQWMyQixPQUFkLENBQXNCLDZCQUF0QjtBQUNEO0FBQ0Y7QUE1RlU7QUFBQTtBQUFBLGdDQThGRDtBQUNSLGFBQUszQixRQUFMLENBQWM0QixHQUFkLENBQWtCLHNCQUFsQjtBQUNBLGFBQUtoQixRQUFMLENBQWNnQixHQUFkLENBQWtCLHNCQUFsQjtBQUVBaEMsU0FBQyxDQUFDc0IsTUFBRCxDQUFELENBQVVVLEdBQVYsQ0FBYyx1QkFBZCxFQUF1QyxLQUFLWixnQkFBNUM7QUFFQVYsa0JBQVUsQ0FBQ3VCLGdCQUFYLENBQTRCLElBQTVCO0FBQ0Q7QUFyR1U7O0FBQUE7QUFBQTs7QUF3R2JoQyxrQkFBZ0IsQ0FBQ0ssUUFBakIsR0FBNEI7QUFDMUI7Ozs7O0FBS0FxQixXQUFPLEVBQUU7QUFOaUIsR0FBNUIsQ0F4R2EsQ0FpSGI7O0FBQ0FqQixZQUFVLENBQUN3QixNQUFYLENBQWtCakMsZ0JBQWxCLEVBQW9DLGtCQUFwQztBQUVDLENBcEhBLENBb0hDa0MsTUFwSEQsQ0FBRCIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4hZnVuY3Rpb24oJCkge1xuXG4vKipcbiAqIFJlc3BvbnNpdmVUb2dnbGUgbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLnJlc3BvbnNpdmVUb2dnbGVcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeVxuICovXG5cbmNsYXNzIFJlc3BvbnNpdmVUb2dnbGUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBUYWIgQmFyLlxuICAgKiBAY2xhc3NcbiAgICogQGZpcmVzIFJlc3BvbnNpdmVUb2dnbGUjaW5pdFxuICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gYXR0YWNoIHRhYiBiYXIgZnVuY3Rpb25hbGl0eSB0by5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuJGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xuICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBSZXNwb25zaXZlVG9nZ2xlLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLl9pbml0KCk7XG4gICAgdGhpcy5fZXZlbnRzKCk7XG5cbiAgICBGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsICdSZXNwb25zaXZlVG9nZ2xlJyk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIHRhYiBiYXIgYnkgZmluZGluZyB0aGUgdGFyZ2V0IGVsZW1lbnQsIHRvZ2dsaW5nIGVsZW1lbnQsIGFuZCBydW5uaW5nIHVwZGF0ZSgpLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0KCkge1xuICAgIHZhciB0YXJnZXRJRCA9IHRoaXMuJGVsZW1lbnQuZGF0YSgncmVzcG9uc2l2ZS10b2dnbGUnKTtcbiAgICBpZiAoIXRhcmdldElEKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdZb3VyIHRhYiBiYXIgbmVlZHMgYW4gSUQgb2YgYSBNZW51IGFzIHRoZSB2YWx1ZSBvZiBkYXRhLXRhYi1iYXIuJyk7XG4gICAgfVxuXG4gICAgdGhpcy4kdGFyZ2V0TWVudSA9ICQoYCMke3RhcmdldElEfWApO1xuICAgIHRoaXMuJHRvZ2dsZXIgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLXRvZ2dsZV0nKTtcblxuICAgIHRoaXMuX3VwZGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgbmVjZXNzYXJ5IGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgdGFiIGJhciB0byB3b3JrLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9ldmVudHMoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuX3VwZGF0ZU1xSGFuZGxlciA9IHRoaXMuX3VwZGF0ZS5iaW5kKHRoaXMpO1xuICAgIFxuICAgICQod2luZG93KS5vbignY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5JywgdGhpcy5fdXBkYXRlTXFIYW5kbGVyKTtcblxuICAgIHRoaXMuJHRvZ2dsZXIub24oJ2NsaWNrLnpmLnJlc3BvbnNpdmVUb2dnbGUnLCB0aGlzLnRvZ2dsZU1lbnUuYmluZCh0aGlzKSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHRoZSBjdXJyZW50IG1lZGlhIHF1ZXJ5IHRvIGRldGVybWluZSBpZiB0aGUgdGFiIGJhciBzaG91bGQgYmUgdmlzaWJsZSBvciBoaWRkZW4uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VwZGF0ZSgpIHtcbiAgICAvLyBNb2JpbGVcbiAgICBpZiAoIUZvdW5kYXRpb24uTWVkaWFRdWVyeS5hdExlYXN0KHRoaXMub3B0aW9ucy5oaWRlRm9yKSkge1xuICAgICAgdGhpcy4kZWxlbWVudC5zaG93KCk7XG4gICAgICB0aGlzLiR0YXJnZXRNZW51LmhpZGUoKTtcbiAgICB9XG5cbiAgICAvLyBEZXNrdG9wXG4gICAgZWxzZSB7XG4gICAgICB0aGlzLiRlbGVtZW50LmhpZGUoKTtcbiAgICAgIHRoaXMuJHRhcmdldE1lbnUuc2hvdygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSBlbGVtZW50IGF0dGFjaGVkIHRvIHRoZSB0YWIgYmFyLiBUaGUgdG9nZ2xlIG9ubHkgaGFwcGVucyBpZiB0aGUgc2NyZWVuIGlzIHNtYWxsIGVub3VnaCB0byBhbGxvdyBpdC5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBmaXJlcyBSZXNwb25zaXZlVG9nZ2xlI3RvZ2dsZWRcbiAgICovXG4gIHRvZ2dsZU1lbnUoKSB7ICAgXG4gICAgaWYgKCFGb3VuZGF0aW9uLk1lZGlhUXVlcnkuYXRMZWFzdCh0aGlzLm9wdGlvbnMuaGlkZUZvcikpIHtcbiAgICAgIHRoaXMuJHRhcmdldE1lbnUudG9nZ2xlKDApO1xuXG4gICAgICAvKipcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGVsZW1lbnQgYXR0YWNoZWQgdG8gdGhlIHRhYiBiYXIgdG9nZ2xlcy5cbiAgICAgICAqIEBldmVudCBSZXNwb25zaXZlVG9nZ2xlI3RvZ2dsZWRcbiAgICAgICAqL1xuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCd0b2dnbGVkLnpmLnJlc3BvbnNpdmVUb2dnbGUnKTtcbiAgICB9XG4gIH07XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiRlbGVtZW50Lm9mZignLnpmLnJlc3BvbnNpdmVUb2dnbGUnKTtcbiAgICB0aGlzLiR0b2dnbGVyLm9mZignLnpmLnJlc3BvbnNpdmVUb2dnbGUnKTtcbiAgICBcbiAgICAkKHdpbmRvdykub2ZmKCdjaGFuZ2VkLnpmLm1lZGlhcXVlcnknLCB0aGlzLl91cGRhdGVNcUhhbmRsZXIpO1xuICAgIFxuICAgIEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTtcbiAgfVxufVxuXG5SZXNwb25zaXZlVG9nZ2xlLmRlZmF1bHRzID0ge1xuICAvKipcbiAgICogVGhlIGJyZWFrcG9pbnQgYWZ0ZXIgd2hpY2ggdGhlIG1lbnUgaXMgYWx3YXlzIHNob3duLCBhbmQgdGhlIHRhYiBiYXIgaXMgaGlkZGVuLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlICdtZWRpdW0nXG4gICAqL1xuICBoaWRlRm9yOiAnbWVkaXVtJ1xufTtcblxuLy8gV2luZG93IGV4cG9ydHNcbkZvdW5kYXRpb24ucGx1Z2luKFJlc3BvbnNpdmVUb2dnbGUsICdSZXNwb25zaXZlVG9nZ2xlJyk7XG5cbn0oalF1ZXJ5KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Jvd2VyX2NvbXBvbmVudHMvZm91bmRhdGlvbi1zaXRlcy9qcy9mb3VuZGF0aW9uLnJlc3BvbnNpdmVUb2dnbGUuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n!function ($) {\n  /**\n   * Sticky module.\n   * @module foundation.sticky\n   * @requires foundation.util.triggers\n   * @requires foundation.util.mediaQuery\n   */\n  var Sticky =\n  /*#__PURE__*/\n  function () {\n    /**\n     * Creates a new instance of a sticky thing.\n     * @class\n     * @param {jQuery} element - jQuery object to make sticky.\n     * @param {Object} options - options object passed when creating the element programmatically.\n     */\n    function Sticky(element, options) {\n      _classCallCheck(this, Sticky);\n\n      this.$element = element;\n      this.options = $.extend({}, Sticky.defaults, this.$element.data(), options);\n\n      this._init();\n\n      Foundation.registerPlugin(this, 'Sticky');\n    }\n    /**\n     * Initializes the sticky element by adding classes, getting/setting dimensions, breakpoints and attributes\n     * @function\n     * @private\n     */\n\n\n    _createClass(Sticky, [{\n      key: \"_init\",\n      value: function _init() {\n        var $parent = this.$element.parent('[data-sticky-container]'),\n            id = this.$element[0].id || Foundation.GetYoDigits(6, 'sticky'),\n            _this = this;\n\n        if (!$parent.length) {\n          this.wasWrapped = true;\n        }\n\n        this.$container = $parent.length ? $parent : $(this.options.container).wrapInner(this.$element);\n        this.$container.addClass(this.options.containerClass);\n        this.$element.addClass(this.options.stickyClass).attr({\n          'data-resize': id\n        });\n        this.scrollCount = this.options.checkEvery;\n        this.isStuck = false;\n        $(window).one('load.zf.sticky', function () {\n          //We calculate the container height to have correct values for anchor points offset calculation.\n          _this.containerHeight = _this.$element.css(\"display\") == \"none\" ? 0 : _this.$element[0].getBoundingClientRect().height;\n\n          _this.$container.css('height', _this.containerHeight);\n\n          _this.elemHeight = _this.containerHeight;\n\n          if (_this.options.anchor !== '') {\n            _this.$anchor = $('#' + _this.options.anchor);\n          } else {\n            _this._parsePoints();\n          }\n\n          _this._setSizes(function () {\n            _this._calc(false);\n          });\n\n          _this._events(id.split('-').reverse().join('-'));\n        });\n      }\n      /**\n       * If using multiple elements as anchors, calculates the top and bottom pixel values the sticky thing should stick and unstick on.\n       * @function\n       * @private\n       */\n\n    }, {\n      key: \"_parsePoints\",\n      value: function _parsePoints() {\n        var top = this.options.topAnchor == \"\" ? 1 : this.options.topAnchor,\n            btm = this.options.btmAnchor == \"\" ? document.documentElement.scrollHeight : this.options.btmAnchor,\n            pts = [top, btm],\n            breaks = {};\n\n        for (var i = 0, len = pts.length; i < len && pts[i]; i++) {\n          var pt;\n\n          if (typeof pts[i] === 'number') {\n            pt = pts[i];\n          } else {\n            var place = pts[i].split(':'),\n                anchor = $(\"#\".concat(place[0]));\n            pt = anchor.offset().top;\n\n            if (place[1] && place[1].toLowerCase() === 'bottom') {\n              pt += anchor[0].getBoundingClientRect().height;\n            }\n          }\n\n          breaks[i] = pt;\n        }\n\n        this.points = breaks;\n        return;\n      }\n      /**\n       * Adds event handlers for the scrolling element.\n       * @private\n       * @param {String} id - psuedo-random id for unique scroll event listener.\n       */\n\n    }, {\n      key: \"_events\",\n      value: function _events(id) {\n        var _this = this,\n            scrollListener = this.scrollListener = \"scroll.zf.\".concat(id);\n\n        if (this.isOn) {\n          return;\n        }\n\n        if (this.canStick) {\n          this.isOn = true;\n          $(window).off(scrollListener).on(scrollListener, function (e) {\n            if (_this.scrollCount === 0) {\n              _this.scrollCount = _this.options.checkEvery;\n\n              _this._setSizes(function () {\n                _this._calc(false, window.pageYOffset);\n              });\n            } else {\n              _this.scrollCount--;\n\n              _this._calc(false, window.pageYOffset);\n            }\n          });\n        }\n\n        this.$element.off('resizeme.zf.trigger').on('resizeme.zf.trigger', function (e, el) {\n          _this._setSizes(function () {\n            _this._calc(false);\n\n            if (_this.canStick) {\n              if (!_this.isOn) {\n                _this._events(id);\n              }\n            } else if (_this.isOn) {\n              _this._pauseListeners(scrollListener);\n            }\n          });\n        });\n      }\n      /**\n       * Removes event handlers for scroll and change events on anchor.\n       * @fires Sticky#pause\n       * @param {String} scrollListener - unique, namespaced scroll listener attached to `window`\n       */\n\n    }, {\n      key: \"_pauseListeners\",\n      value: function _pauseListeners(scrollListener) {\n        this.isOn = false;\n        $(window).off(scrollListener);\n        /**\n         * Fires when the plugin is paused due to resize event shrinking the view.\n         * @event Sticky#pause\n         * @private\n         */\n\n        this.$element.trigger('pause.zf.sticky');\n      }\n      /**\n       * Called on every `scroll` event and on `_init`\n       * fires functions based on booleans and cached values\n       * @param {Boolean} checkSizes - true if plugin should recalculate sizes and breakpoints.\n       * @param {Number} scroll - current scroll position passed from scroll event cb function. If not passed, defaults to `window.pageYOffset`.\n       */\n\n    }, {\n      key: \"_calc\",\n      value: function _calc(checkSizes, scroll) {\n        if (checkSizes) {\n          this._setSizes();\n        }\n\n        if (!this.canStick) {\n          if (this.isStuck) {\n            this._removeSticky(true);\n          }\n\n          return false;\n        }\n\n        if (!scroll) {\n          scroll = window.pageYOffset;\n        }\n\n        if (scroll >= this.topPoint) {\n          if (scroll <= this.bottomPoint) {\n            if (!this.isStuck) {\n              this._setSticky();\n            }\n          } else {\n            if (this.isStuck) {\n              this._removeSticky(false);\n            }\n          }\n        } else {\n          if (this.isStuck) {\n            this._removeSticky(true);\n          }\n        }\n      }\n      /**\n       * Causes the $element to become stuck.\n       * Adds `position: fixed;`, and helper classes.\n       * @fires Sticky#stuckto\n       * @function\n       * @private\n       */\n\n    }, {\n      key: \"_setSticky\",\n      value: function _setSticky() {\n        var _this = this,\n            stickTo = this.options.stickTo,\n            mrgn = stickTo === 'top' ? 'marginTop' : 'marginBottom',\n            notStuckTo = stickTo === 'top' ? 'bottom' : 'top',\n            css = {};\n\n        css[mrgn] = \"\".concat(this.options[mrgn], \"em\");\n        css[stickTo] = 0;\n        css[notStuckTo] = 'auto';\n        css['left'] = this.$container.offset().left + parseInt(window.getComputedStyle(this.$container[0])[\"padding-left\"], 10);\n        this.isStuck = true;\n        this.$element.removeClass(\"is-anchored is-at-\".concat(notStuckTo)).addClass(\"is-stuck is-at-\".concat(stickTo)).css(css)\n        /**\n         * Fires when the $element has become `position: fixed;`\n         * Namespaced to `top` or `bottom`, e.g. `sticky.zf.stuckto:top`\n         * @event Sticky#stuckto\n         */\n        .trigger(\"sticky.zf.stuckto:\".concat(stickTo));\n        this.$element.on(\"transitionend webkitTransitionEnd oTransitionEnd otransitionend MSTransitionEnd\", function () {\n          _this._setSizes();\n        });\n      }\n      /**\n       * Causes the $element to become unstuck.\n       * Removes `position: fixed;`, and helper classes.\n       * Adds other helper classes.\n       * @param {Boolean} isTop - tells the function if the $element should anchor to the top or bottom of its $anchor element.\n       * @fires Sticky#unstuckfrom\n       * @private\n       */\n\n    }, {\n      key: \"_removeSticky\",\n      value: function _removeSticky(isTop) {\n        var stickTo = this.options.stickTo,\n            stickToTop = stickTo === 'top',\n            css = {},\n            anchorPt = (this.points ? this.points[1] - this.points[0] : this.anchorHeight) - this.elemHeight,\n            mrgn = stickToTop ? 'marginTop' : 'marginBottom',\n            notStuckTo = stickToTop ? 'bottom' : 'top',\n            topOrBottom = isTop ? 'top' : 'bottom';\n        css[mrgn] = 0;\n        css['bottom'] = 'auto';\n\n        if (isTop) {\n          css['top'] = 0;\n        } else {\n          css['top'] = anchorPt;\n        }\n\n        css['left'] = '';\n        this.isStuck = false;\n        this.$element.removeClass(\"is-stuck is-at-\".concat(stickTo)).addClass(\"is-anchored is-at-\".concat(topOrBottom)).css(css)\n        /**\n         * Fires when the $element has become anchored.\n         * Namespaced to `top` or `bottom`, e.g. `sticky.zf.unstuckfrom:bottom`\n         * @event Sticky#unstuckfrom\n         */\n        .trigger(\"sticky.zf.unstuckfrom:\".concat(topOrBottom));\n      }\n      /**\n       * Sets the $element and $container sizes for plugin.\n       * Calls `_setBreakPoints`.\n       * @param {Function} cb - optional callback function to fire on completion of `_setBreakPoints`.\n       * @private\n       */\n\n    }, {\n      key: \"_setSizes\",\n      value: function _setSizes(cb) {\n        this.canStick = Foundation.MediaQuery.atLeast(this.options.stickyOn);\n\n        if (!this.canStick) {\n          if (cb && typeof cb === 'function') {\n            cb();\n          }\n        }\n\n        var _this = this,\n            newElemWidth = this.$container[0].getBoundingClientRect().width,\n            comp = window.getComputedStyle(this.$container[0]),\n            pdng = parseInt(comp['padding-right'], 10);\n\n        if (this.$anchor && this.$anchor.length) {\n          this.anchorHeight = this.$anchor[0].getBoundingClientRect().height;\n        } else {\n          this._parsePoints();\n        }\n\n        this.$element.css({\n          'max-width': \"\".concat(newElemWidth - pdng, \"px\")\n        });\n        var newContainerHeight = this.$element[0].getBoundingClientRect().height || this.containerHeight;\n\n        if (this.$element.css(\"display\") == \"none\") {\n          newContainerHeight = 0;\n        }\n\n        this.containerHeight = newContainerHeight;\n        this.$container.css({\n          height: newContainerHeight\n        });\n        this.elemHeight = newContainerHeight;\n\n        if (this.isStuck) {\n          this.$element.css({\n            \"left\": this.$container.offset().left + parseInt(comp['padding-left'], 10)\n          });\n        } else {\n          if (this.$element.hasClass('is-at-bottom')) {\n            var anchorPt = (this.points ? this.points[1] - this.$container.offset().top : this.anchorHeight) - this.elemHeight;\n            this.$element.css('top', anchorPt);\n          }\n        }\n\n        this._setBreakPoints(newContainerHeight, function () {\n          if (cb && typeof cb === 'function') {\n            cb();\n          }\n        });\n      }\n      /**\n       * Sets the upper and lower breakpoints for the element to become sticky/unsticky.\n       * @param {Number} elemHeight - px value for sticky.$element height, calculated by `_setSizes`.\n       * @param {Function} cb - optional callback function to be called on completion.\n       * @private\n       */\n\n    }, {\n      key: \"_setBreakPoints\",\n      value: function _setBreakPoints(elemHeight, cb) {\n        if (!this.canStick) {\n          if (cb && typeof cb === 'function') {\n            cb();\n          } else {\n            return false;\n          }\n        }\n\n        var mTop = emCalc(this.options.marginTop),\n            mBtm = emCalc(this.options.marginBottom),\n            topPoint = this.points ? this.points[0] : this.$anchor.offset().top,\n            bottomPoint = this.points ? this.points[1] : topPoint + this.anchorHeight,\n            // topPoint = this.$anchor.offset().top || this.points[0],\n        // bottomPoint = topPoint + this.anchorHeight || this.points[1],\n        winHeight = window.innerHeight;\n\n        if (this.options.stickTo === 'top') {\n          topPoint -= mTop;\n          bottomPoint -= elemHeight + mTop;\n        } else if (this.options.stickTo === 'bottom') {\n          topPoint -= winHeight - (elemHeight + mBtm);\n          bottomPoint -= winHeight - mBtm;\n        } else {//this would be the stickTo: both option... tricky\n        }\n\n        this.topPoint = topPoint;\n        this.bottomPoint = bottomPoint;\n\n        if (cb && typeof cb === 'function') {\n          cb();\n        }\n      }\n      /**\n       * Destroys the current sticky element.\n       * Resets the element to the top position first.\n       * Removes event listeners, JS-added css properties and classes, and unwraps the $element if the JS added the $container.\n       * @function\n       */\n\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        this._removeSticky(true);\n\n        this.$element.removeClass(\"\".concat(this.options.stickyClass, \" is-anchored is-at-top\")).css({\n          height: '',\n          top: '',\n          bottom: '',\n          'max-width': ''\n        }).off('resizeme.zf.trigger');\n\n        if (this.$anchor && this.$anchor.length) {\n          this.$anchor.off('change.zf.sticky');\n        }\n\n        $(window).off(this.scrollListener);\n\n        if (this.wasWrapped) {\n          this.$element.unwrap();\n        } else {\n          this.$container.removeClass(this.options.containerClass).css({\n            height: ''\n          });\n        }\n\n        Foundation.unregisterPlugin(this);\n      }\n    }]);\n\n    return Sticky;\n  }();\n\n  Sticky.defaults = {\n    /**\n     * Customizable container template. Add your own classes for styling and sizing.\n     * @option\n     * @example '&lt;div data-sticky-container class=\"small-6 columns\"&gt;&lt;/div&gt;'\n     */\n    container: '<div data-sticky-container></div>',\n\n    /**\n     * Location in the view the element sticks to.\n     * @option\n     * @example 'top'\n     */\n    stickTo: 'top',\n\n    /**\n     * If anchored to a single element, the id of that element.\n     * @option\n     * @example 'exampleId'\n     */\n    anchor: '',\n\n    /**\n     * If using more than one element as anchor points, the id of the top anchor.\n     * @option\n     * @example 'exampleId:top'\n     */\n    topAnchor: '',\n\n    /**\n     * If using more than one element as anchor points, the id of the bottom anchor.\n     * @option\n     * @example 'exampleId:bottom'\n     */\n    btmAnchor: '',\n\n    /**\n     * Margin, in `em`'s to apply to the top of the element when it becomes sticky.\n     * @option\n     * @example 1\n     */\n    marginTop: 1,\n\n    /**\n     * Margin, in `em`'s to apply to the bottom of the element when it becomes sticky.\n     * @option\n     * @example 1\n     */\n    marginBottom: 1,\n\n    /**\n     * Breakpoint string that is the minimum screen size an element should become sticky.\n     * @option\n     * @example 'medium'\n     */\n    stickyOn: 'medium',\n\n    /**\n     * Class applied to sticky element, and removed on destruction. Foundation defaults to `sticky`.\n     * @option\n     * @example 'sticky'\n     */\n    stickyClass: 'sticky',\n\n    /**\n     * Class applied to sticky container. Foundation defaults to `sticky-container`.\n     * @option\n     * @example 'sticky-container'\n     */\n    containerClass: 'sticky-container',\n\n    /**\n     * Number of scroll events between the plugin's recalculating sticky points. Setting it to `0` will cause it to recalc every scroll event, setting it to `-1` will prevent recalc on scroll.\n     * @option\n     * @example 50\n     */\n    checkEvery: -1\n  };\n  /**\n   * Helper function to calculate em values\n   * @param Number {em} - number of em's to calculate into pixels\n   */\n\n  function emCalc(em) {\n    return parseInt(window.getComputedStyle(document.body, null).fontSize, 10) * em;\n  } // Window exports\n\n\n  Foundation.plugin(Sticky, 'Sticky');\n}(jQuery);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2ZvdW5kYXRpb24tc2l0ZXMvanMvZm91bmRhdGlvbi5zdGlja3kuanM/MjRlZiJdLCJuYW1lcyI6WyIkIiwiU3RpY2t5IiwiZWxlbWVudCIsIm9wdGlvbnMiLCIkZWxlbWVudCIsImV4dGVuZCIsImRlZmF1bHRzIiwiZGF0YSIsIl9pbml0IiwiRm91bmRhdGlvbiIsInJlZ2lzdGVyUGx1Z2luIiwiJHBhcmVudCIsInBhcmVudCIsImlkIiwiR2V0WW9EaWdpdHMiLCJfdGhpcyIsImxlbmd0aCIsIndhc1dyYXBwZWQiLCIkY29udGFpbmVyIiwiY29udGFpbmVyIiwid3JhcElubmVyIiwiYWRkQ2xhc3MiLCJjb250YWluZXJDbGFzcyIsInN0aWNreUNsYXNzIiwiYXR0ciIsInNjcm9sbENvdW50IiwiY2hlY2tFdmVyeSIsImlzU3R1Y2siLCJ3aW5kb3ciLCJvbmUiLCJjb250YWluZXJIZWlnaHQiLCJjc3MiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJoZWlnaHQiLCJlbGVtSGVpZ2h0IiwiYW5jaG9yIiwiJGFuY2hvciIsIl9wYXJzZVBvaW50cyIsIl9zZXRTaXplcyIsIl9jYWxjIiwiX2V2ZW50cyIsInNwbGl0IiwicmV2ZXJzZSIsImpvaW4iLCJ0b3AiLCJ0b3BBbmNob3IiLCJidG0iLCJidG1BbmNob3IiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsInNjcm9sbEhlaWdodCIsInB0cyIsImJyZWFrcyIsImkiLCJsZW4iLCJwdCIsInBsYWNlIiwib2Zmc2V0IiwidG9Mb3dlckNhc2UiLCJwb2ludHMiLCJzY3JvbGxMaXN0ZW5lciIsImlzT24iLCJjYW5TdGljayIsIm9mZiIsIm9uIiwiZSIsInBhZ2VZT2Zmc2V0IiwiZWwiLCJfcGF1c2VMaXN0ZW5lcnMiLCJ0cmlnZ2VyIiwiY2hlY2tTaXplcyIsInNjcm9sbCIsIl9yZW1vdmVTdGlja3kiLCJ0b3BQb2ludCIsImJvdHRvbVBvaW50IiwiX3NldFN0aWNreSIsInN0aWNrVG8iLCJtcmduIiwibm90U3R1Y2tUbyIsImxlZnQiLCJwYXJzZUludCIsImdldENvbXB1dGVkU3R5bGUiLCJyZW1vdmVDbGFzcyIsImlzVG9wIiwic3RpY2tUb1RvcCIsImFuY2hvclB0IiwiYW5jaG9ySGVpZ2h0IiwidG9wT3JCb3R0b20iLCJjYiIsIk1lZGlhUXVlcnkiLCJhdExlYXN0Iiwic3RpY2t5T24iLCJuZXdFbGVtV2lkdGgiLCJ3aWR0aCIsImNvbXAiLCJwZG5nIiwibmV3Q29udGFpbmVySGVpZ2h0IiwiaGFzQ2xhc3MiLCJfc2V0QnJlYWtQb2ludHMiLCJtVG9wIiwiZW1DYWxjIiwibWFyZ2luVG9wIiwibUJ0bSIsIm1hcmdpbkJvdHRvbSIsIndpbkhlaWdodCIsImlubmVySGVpZ2h0IiwiYm90dG9tIiwidW53cmFwIiwidW5yZWdpc3RlclBsdWdpbiIsImVtIiwiYm9keSIsImZvbnRTaXplIiwicGx1Z2luIiwialF1ZXJ5Il0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7QUFFQSxDQUFDLFVBQVNBLENBQVQsRUFBWTtBQUViOzs7Ozs7QUFGYSxNQVNQQyxNQVRPO0FBQUE7QUFBQTtBQVVYOzs7Ozs7QUFNQSxvQkFBWUMsT0FBWixFQUFxQkMsT0FBckIsRUFBOEI7QUFBQTs7QUFDNUIsV0FBS0MsUUFBTCxHQUFnQkYsT0FBaEI7QUFDQSxXQUFLQyxPQUFMLEdBQWVILENBQUMsQ0FBQ0ssTUFBRixDQUFTLEVBQVQsRUFBYUosTUFBTSxDQUFDSyxRQUFwQixFQUE4QixLQUFLRixRQUFMLENBQWNHLElBQWQsRUFBOUIsRUFBb0RKLE9BQXBELENBQWY7O0FBRUEsV0FBS0ssS0FBTDs7QUFFQUMsZ0JBQVUsQ0FBQ0MsY0FBWCxDQUEwQixJQUExQixFQUFnQyxRQUFoQztBQUNEO0FBRUQ7Ozs7Ozs7QUF6Qlc7QUFBQTtBQUFBLDhCQThCSDtBQUNOLFlBQUlDLE9BQU8sR0FBRyxLQUFLUCxRQUFMLENBQWNRLE1BQWQsQ0FBcUIseUJBQXJCLENBQWQ7QUFBQSxZQUNJQyxF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Y2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbiFmdW5jdGlvbigkKSB7XG5cbi8qKlxuICogU3RpY2t5IG1vZHVsZS5cbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5zdGlja3lcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnNcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeVxuICovXG5cbmNsYXNzIFN0aWNreSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGEgc3RpY2t5IHRoaW5nLlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIG1ha2Ugc3RpY2t5LlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgb2JqZWN0IHBhc3NlZCB3aGVuIGNyZWF0aW5nIHRoZSBlbGVtZW50IHByb2dyYW1tYXRpY2FsbHkuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIFN0aWNreS5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5faW5pdCgpO1xuXG4gICAgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLCAnU3RpY2t5Jyk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIHN0aWNreSBlbGVtZW50IGJ5IGFkZGluZyBjbGFzc2VzLCBnZXR0aW5nL3NldHRpbmcgZGltZW5zaW9ucywgYnJlYWtwb2ludHMgYW5kIGF0dHJpYnV0ZXNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaW5pdCgpIHtcbiAgICB2YXIgJHBhcmVudCA9IHRoaXMuJGVsZW1lbnQucGFyZW50KCdbZGF0YS1zdGlja3ktY29udGFpbmVyXScpLFxuICAgICAgICBpZCA9IHRoaXMuJGVsZW1lbnRbMF0uaWQgfHwgRm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LCAnc3RpY2t5JyksXG4gICAgICAgIF90aGlzID0gdGhpcztcblxuICAgIGlmICghJHBhcmVudC5sZW5ndGgpIHtcbiAgICAgIHRoaXMud2FzV3JhcHBlZCA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuJGNvbnRhaW5lciA9ICRwYXJlbnQubGVuZ3RoID8gJHBhcmVudCA6ICQodGhpcy5vcHRpb25zLmNvbnRhaW5lcikud3JhcElubmVyKHRoaXMuJGVsZW1lbnQpO1xuICAgIHRoaXMuJGNvbnRhaW5lci5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuY29udGFpbmVyQ2xhc3MpO1xuXG4gICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuc3RpY2t5Q2xhc3MpXG4gICAgICAgICAgICAgICAgIC5hdHRyKHsnZGF0YS1yZXNpemUnOiBpZH0pO1xuXG4gICAgdGhpcy5zY3JvbGxDb3VudCA9IHRoaXMub3B0aW9ucy5jaGVja0V2ZXJ5O1xuICAgIHRoaXMuaXNTdHVjayA9IGZhbHNlO1xuICAgICQod2luZG93KS5vbmUoJ2xvYWQuemYuc3RpY2t5JywgZnVuY3Rpb24oKXtcbiAgICAgIC8vV2UgY2FsY3VsYXRlIHRoZSBjb250YWluZXIgaGVpZ2h0IHRvIGhhdmUgY29ycmVjdCB2YWx1ZXMgZm9yIGFuY2hvciBwb2ludHMgb2Zmc2V0IGNhbGN1bGF0aW9uLlxuICAgICAgX3RoaXMuY29udGFpbmVySGVpZ2h0ID0gX3RoaXMuJGVsZW1lbnQuY3NzKFwiZGlzcGxheVwiKSA9PSBcIm5vbmVcIiA/IDAgOiBfdGhpcy4kZWxlbWVudFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgICBfdGhpcy4kY29udGFpbmVyLmNzcygnaGVpZ2h0JywgX3RoaXMuY29udGFpbmVySGVpZ2h0KTtcbiAgICAgIF90aGlzLmVsZW1IZWlnaHQgPSBfdGhpcy5jb250YWluZXJIZWlnaHQ7XG4gICAgICBpZihfdGhpcy5vcHRpb25zLmFuY2hvciAhPT0gJycpe1xuICAgICAgICBfdGhpcy4kYW5jaG9yID0gJCgnIycgKyBfdGhpcy5vcHRpb25zLmFuY2hvcik7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgX3RoaXMuX3BhcnNlUG9pbnRzKCk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLl9zZXRTaXplcyhmdW5jdGlvbigpe1xuICAgICAgICBfdGhpcy5fY2FsYyhmYWxzZSk7XG4gICAgICB9KTtcbiAgICAgIF90aGlzLl9ldmVudHMoaWQuc3BsaXQoJy0nKS5yZXZlcnNlKCkuam9pbignLScpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB1c2luZyBtdWx0aXBsZSBlbGVtZW50cyBhcyBhbmNob3JzLCBjYWxjdWxhdGVzIHRoZSB0b3AgYW5kIGJvdHRvbSBwaXhlbCB2YWx1ZXMgdGhlIHN0aWNreSB0aGluZyBzaG91bGQgc3RpY2sgYW5kIHVuc3RpY2sgb24uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3BhcnNlUG9pbnRzKCkge1xuICAgIHZhciB0b3AgPSB0aGlzLm9wdGlvbnMudG9wQW5jaG9yID09IFwiXCIgPyAxIDogdGhpcy5vcHRpb25zLnRvcEFuY2hvcixcbiAgICAgICAgYnRtID0gdGhpcy5vcHRpb25zLmJ0bUFuY2hvcj09IFwiXCIgPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0IDogdGhpcy5vcHRpb25zLmJ0bUFuY2hvcixcbiAgICAgICAgcHRzID0gW3RvcCwgYnRtXSxcbiAgICAgICAgYnJlYWtzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHB0cy5sZW5ndGg7IGkgPCBsZW4gJiYgcHRzW2ldOyBpKyspIHtcbiAgICAgIHZhciBwdDtcbiAgICAgIGlmICh0eXBlb2YgcHRzW2ldID09PSAnbnVtYmVyJykge1xuICAgICAgICBwdCA9IHB0c1tpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwbGFjZSA9IHB0c1tpXS5zcGxpdCgnOicpLFxuICAgICAgICAgICAgYW5jaG9yID0gJChgIyR7cGxhY2VbMF19YCk7XG5cbiAgICAgICAgcHQgPSBhbmNob3Iub2Zmc2V0KCkudG9wO1xuICAgICAgICBpZiAocGxhY2VbMV0gJiYgcGxhY2VbMV0udG9Mb3dlckNhc2UoKSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICBwdCArPSBhbmNob3JbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha3NbaV0gPSBwdDtcbiAgICB9XG5cblxuICAgIHRoaXMucG9pbnRzID0gYnJlYWtzO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgc2Nyb2xsaW5nIGVsZW1lbnQuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpZCAtIHBzdWVkby1yYW5kb20gaWQgZm9yIHVuaXF1ZSBzY3JvbGwgZXZlbnQgbGlzdGVuZXIuXG4gICAqL1xuICBfZXZlbnRzKGlkKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgc2Nyb2xsTGlzdGVuZXIgPSB0aGlzLnNjcm9sbExpc3RlbmVyID0gYHNjcm9sbC56Zi4ke2lkfWA7XG4gICAgaWYgKHRoaXMuaXNPbikgeyByZXR1cm47IH1cbiAgICBpZiAodGhpcy5jYW5TdGljaykge1xuICAgICAgdGhpcy5pc09uID0gdHJ1ZTtcbiAgICAgICQod2luZG93KS5vZmYoc2Nyb2xsTGlzdGVuZXIpXG4gICAgICAgICAgICAgICAub24oc2Nyb2xsTGlzdGVuZXIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnNjcm9sbENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgX3RoaXMuc2Nyb2xsQ291bnQgPSBfdGhpcy5vcHRpb25zLmNoZWNrRXZlcnk7XG4gICAgICAgICAgICAgICAgICAgX3RoaXMuX3NldFNpemVzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2NhbGMoZmFsc2UsIHdpbmRvdy5wYWdlWU9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgX3RoaXMuc2Nyb2xsQ291bnQtLTtcbiAgICAgICAgICAgICAgICAgICBfdGhpcy5fY2FsYyhmYWxzZSwgd2luZG93LnBhZ2VZT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLiRlbGVtZW50Lm9mZigncmVzaXplbWUuemYudHJpZ2dlcicpXG4gICAgICAgICAgICAgICAgIC5vbigncmVzaXplbWUuemYudHJpZ2dlcicsIGZ1bmN0aW9uKGUsIGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2V0U2l6ZXMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9jYWxjKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmNhblN0aWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5pc09uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZXZlbnRzKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoX3RoaXMuaXNPbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9wYXVzZUxpc3RlbmVycyhzY3JvbGxMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgZXZlbnQgaGFuZGxlcnMgZm9yIHNjcm9sbCBhbmQgY2hhbmdlIGV2ZW50cyBvbiBhbmNob3IuXG4gICAqIEBmaXJlcyBTdGlja3kjcGF1c2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNjcm9sbExpc3RlbmVyIC0gdW5pcXVlLCBuYW1lc3BhY2VkIHNjcm9sbCBsaXN0ZW5lciBhdHRhY2hlZCB0byBgd2luZG93YFxuICAgKi9cbiAgX3BhdXNlTGlzdGVuZXJzKHNjcm9sbExpc3RlbmVyKSB7XG4gICAgdGhpcy5pc09uID0gZmFsc2U7XG4gICAgJCh3aW5kb3cpLm9mZihzY3JvbGxMaXN0ZW5lcik7XG5cbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHRoZSBwbHVnaW4gaXMgcGF1c2VkIGR1ZSB0byByZXNpemUgZXZlbnQgc2hyaW5raW5nIHRoZSB2aWV3LlxuICAgICAqIEBldmVudCBTdGlja3kjcGF1c2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3BhdXNlLnpmLnN0aWNreScpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCBvbiBldmVyeSBgc2Nyb2xsYCBldmVudCBhbmQgb24gYF9pbml0YFxuICAgKiBmaXJlcyBmdW5jdGlvbnMgYmFzZWQgb24gYm9vbGVhbnMgYW5kIGNhY2hlZCB2YWx1ZXNcbiAgICogQHBhcmFtIHtCb29sZWFufSBjaGVja1NpemVzIC0gdHJ1ZSBpZiBwbHVnaW4gc2hvdWxkIHJlY2FsY3VsYXRlIHNpemVzIGFuZCBicmVha3BvaW50cy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNjcm9sbCAtIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIHBhc3NlZCBmcm9tIHNjcm9sbCBldmVudCBjYiBmdW5jdGlvbi4gSWYgbm90IHBhc3NlZCwgZGVmYXVsdHMgdG8gYHdpbmRvdy5wYWdlWU9mZnNldGAuXG4gICAqL1xuICBfY2FsYyhjaGVja1NpemVzLCBzY3JvbGwpIHtcbiAgICBpZiAoY2hlY2tTaXplcykgeyB0aGlzLl9zZXRTaXplcygpOyB9XG5cbiAgICBpZiAoIXRoaXMuY2FuU3RpY2spIHtcbiAgICAgIGlmICh0aGlzLmlzU3R1Y2spIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlU3RpY2t5KHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghc2Nyb2xsKSB7IHNjcm9sbCA9IHdpbmRvdy5wYWdlWU9mZnNldDsgfVxuXG4gICAgaWYgKHNjcm9sbCA+PSB0aGlzLnRvcFBvaW50KSB7XG4gICAgICBpZiAoc2Nyb2xsIDw9IHRoaXMuYm90dG9tUG9pbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3R1Y2spIHtcbiAgICAgICAgICB0aGlzLl9zZXRTdGlja3koKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTdHVjaykge1xuICAgICAgICAgIHRoaXMuX3JlbW92ZVN0aWNreShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuaXNTdHVjaykge1xuICAgICAgICB0aGlzLl9yZW1vdmVTdGlja3kodHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhdXNlcyB0aGUgJGVsZW1lbnQgdG8gYmVjb21lIHN0dWNrLlxuICAgKiBBZGRzIGBwb3NpdGlvbjogZml4ZWQ7YCwgYW5kIGhlbHBlciBjbGFzc2VzLlxuICAgKiBAZmlyZXMgU3RpY2t5I3N0dWNrdG9cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0U3RpY2t5KCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgIHN0aWNrVG8gPSB0aGlzLm9wdGlvbnMuc3RpY2tUbyxcbiAgICAgICAgbXJnbiA9IHN0aWNrVG8gPT09ICd0b3AnID8gJ21hcmdpblRvcCcgOiAnbWFyZ2luQm90dG9tJyxcbiAgICAgICAgbm90U3R1Y2tUbyA9IHN0aWNrVG8gPT09ICd0b3AnID8gJ2JvdHRvbScgOiAndG9wJyxcbiAgICAgICAgY3NzID0ge307XG5cbiAgICBjc3NbbXJnbl0gPSBgJHt0aGlzLm9wdGlvbnNbbXJnbl19ZW1gO1xuICAgIGNzc1tzdGlja1RvXSA9IDA7XG4gICAgY3NzW25vdFN0dWNrVG9dID0gJ2F1dG8nO1xuICAgIGNzc1snbGVmdCddID0gdGhpcy4kY29udGFpbmVyLm9mZnNldCgpLmxlZnQgKyBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiRjb250YWluZXJbMF0pW1wicGFkZGluZy1sZWZ0XCJdLCAxMCk7XG4gICAgdGhpcy5pc1N0dWNrID0gdHJ1ZTtcbiAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKGBpcy1hbmNob3JlZCBpcy1hdC0ke25vdFN0dWNrVG99YClcbiAgICAgICAgICAgICAgICAgLmFkZENsYXNzKGBpcy1zdHVjayBpcy1hdC0ke3N0aWNrVG99YClcbiAgICAgICAgICAgICAgICAgLmNzcyhjc3MpXG4gICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSAkZWxlbWVudCBoYXMgYmVjb21lIGBwb3NpdGlvbjogZml4ZWQ7YFxuICAgICAgICAgICAgICAgICAgKiBOYW1lc3BhY2VkIHRvIGB0b3BgIG9yIGBib3R0b21gLCBlLmcuIGBzdGlja3kuemYuc3R1Y2t0bzp0b3BgXG4gICAgICAgICAgICAgICAgICAqIEBldmVudCBTdGlja3kjc3R1Y2t0b1xuICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgLnRyaWdnZXIoYHN0aWNreS56Zi5zdHVja3RvOiR7c3RpY2tUb31gKTtcbiAgICB0aGlzLiRlbGVtZW50Lm9uKFwidHJhbnNpdGlvbmVuZCB3ZWJraXRUcmFuc2l0aW9uRW5kIG9UcmFuc2l0aW9uRW5kIG90cmFuc2l0aW9uZW5kIE1TVHJhbnNpdGlvbkVuZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgIF90aGlzLl9zZXRTaXplcygpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENhdXNlcyB0aGUgJGVsZW1lbnQgdG8gYmVjb21lIHVuc3R1Y2suXG4gICAqIFJlbW92ZXMgYHBvc2l0aW9uOiBmaXhlZDtgLCBhbmQgaGVscGVyIGNsYXNzZXMuXG4gICAqIEFkZHMgb3RoZXIgaGVscGVyIGNsYXNzZXMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNUb3AgLSB0ZWxscyB0aGUgZnVuY3Rpb24gaWYgdGhlICRlbGVtZW50IHNob3VsZCBhbmNob3IgdG8gdGhlIHRvcCBvciBib3R0b20gb2YgaXRzICRhbmNob3IgZWxlbWVudC5cbiAgICogQGZpcmVzIFN0aWNreSN1bnN0dWNrZnJvbVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbW92ZVN0aWNreShpc1RvcCkge1xuICAgIHZhciBzdGlja1RvID0gdGhpcy5vcHRpb25zLnN0aWNrVG8sXG4gICAgICAgIHN0aWNrVG9Ub3AgPSBzdGlja1RvID09PSAndG9wJyxcbiAgICAgICAgY3NzID0ge30sXG4gICAgICAgIGFuY2hvclB0ID0gKHRoaXMucG9pbnRzID8gdGhpcy5wb2ludHNbMV0gLSB0aGlzLnBvaW50c1swXSA6IHRoaXMuYW5jaG9ySGVpZ2h0KSAtIHRoaXMuZWxlbUhlaWdodCxcbiAgICAgICAgbXJnbiA9IHN0aWNrVG9Ub3AgPyAnbWFyZ2luVG9wJyA6ICdtYXJnaW5Cb3R0b20nLFxuICAgICAgICBub3RTdHVja1RvID0gc3RpY2tUb1RvcCA/ICdib3R0b20nIDogJ3RvcCcsXG4gICAgICAgIHRvcE9yQm90dG9tID0gaXNUb3AgPyAndG9wJyA6ICdib3R0b20nO1xuXG4gICAgY3NzW21yZ25dID0gMDtcblxuICAgIGNzc1snYm90dG9tJ10gPSAnYXV0byc7XG4gICAgaWYoaXNUb3ApIHtcbiAgICAgIGNzc1sndG9wJ10gPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjc3NbJ3RvcCddID0gYW5jaG9yUHQ7XG4gICAgfVxuXG4gICAgY3NzWydsZWZ0J10gPSAnJztcbiAgICB0aGlzLmlzU3R1Y2sgPSBmYWxzZTtcbiAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKGBpcy1zdHVjayBpcy1hdC0ke3N0aWNrVG99YClcbiAgICAgICAgICAgICAgICAgLmFkZENsYXNzKGBpcy1hbmNob3JlZCBpcy1hdC0ke3RvcE9yQm90dG9tfWApXG4gICAgICAgICAgICAgICAgIC5jc3MoY3NzKVxuICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgJGVsZW1lbnQgaGFzIGJlY29tZSBhbmNob3JlZC5cbiAgICAgICAgICAgICAgICAgICogTmFtZXNwYWNlZCB0byBgdG9wYCBvciBgYm90dG9tYCwgZS5nLiBgc3RpY2t5LnpmLnVuc3R1Y2tmcm9tOmJvdHRvbWBcbiAgICAgICAgICAgICAgICAgICogQGV2ZW50IFN0aWNreSN1bnN0dWNrZnJvbVxuICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgLnRyaWdnZXIoYHN0aWNreS56Zi51bnN0dWNrZnJvbToke3RvcE9yQm90dG9tfWApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlICRlbGVtZW50IGFuZCAkY29udGFpbmVyIHNpemVzIGZvciBwbHVnaW4uXG4gICAqIENhbGxzIGBfc2V0QnJlYWtQb2ludHNgLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGZpcmUgb24gY29tcGxldGlvbiBvZiBgX3NldEJyZWFrUG9pbnRzYC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRTaXplcyhjYikge1xuICAgIHRoaXMuY2FuU3RpY2sgPSBGb3VuZGF0aW9uLk1lZGlhUXVlcnkuYXRMZWFzdCh0aGlzLm9wdGlvbnMuc3RpY2t5T24pO1xuICAgIGlmICghdGhpcy5jYW5TdGljaykge1xuICAgICAgaWYgKGNiICYmIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykgeyBjYigpOyB9XG4gICAgfVxuICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgIG5ld0VsZW1XaWR0aCA9IHRoaXMuJGNvbnRhaW5lclswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCxcbiAgICAgICAgY29tcCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuJGNvbnRhaW5lclswXSksXG4gICAgICAgIHBkbmcgPSBwYXJzZUludChjb21wWydwYWRkaW5nLXJpZ2h0J10sIDEwKTtcblxuICAgIGlmICh0aGlzLiRhbmNob3IgJiYgdGhpcy4kYW5jaG9yLmxlbmd0aCkge1xuICAgICAgdGhpcy5hbmNob3JIZWlnaHQgPSB0aGlzLiRhbmNob3JbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9wYXJzZVBvaW50cygpO1xuICAgIH1cblxuICAgIHRoaXMuJGVsZW1lbnQuY3NzKHtcbiAgICAgICdtYXgtd2lkdGgnOiBgJHtuZXdFbGVtV2lkdGggLSBwZG5nfXB4YFxuICAgIH0pO1xuXG4gICAgdmFyIG5ld0NvbnRhaW5lckhlaWdodCA9IHRoaXMuJGVsZW1lbnRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0IHx8IHRoaXMuY29udGFpbmVySGVpZ2h0O1xuICAgIGlmICh0aGlzLiRlbGVtZW50LmNzcyhcImRpc3BsYXlcIikgPT0gXCJub25lXCIpIHtcbiAgICAgIG5ld0NvbnRhaW5lckhlaWdodCA9IDA7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVySGVpZ2h0ID0gbmV3Q29udGFpbmVySGVpZ2h0O1xuICAgIHRoaXMuJGNvbnRhaW5lci5jc3Moe1xuICAgICAgaGVpZ2h0OiBuZXdDb250YWluZXJIZWlnaHRcbiAgICB9KTtcbiAgICB0aGlzLmVsZW1IZWlnaHQgPSBuZXdDb250YWluZXJIZWlnaHQ7XG5cbiAgICBpZiAodGhpcy5pc1N0dWNrKSB7XG4gICAgICB0aGlzLiRlbGVtZW50LmNzcyh7XCJsZWZ0XCI6dGhpcy4kY29udGFpbmVyLm9mZnNldCgpLmxlZnQgKyBwYXJzZUludChjb21wWydwYWRkaW5nLWxlZnQnXSwgMTApfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdpcy1hdC1ib3R0b20nKSkge1xuICAgICAgICB2YXIgYW5jaG9yUHQgPSAodGhpcy5wb2ludHMgPyB0aGlzLnBvaW50c1sxXSAtIHRoaXMuJGNvbnRhaW5lci5vZmZzZXQoKS50b3AgOiB0aGlzLmFuY2hvckhlaWdodCkgLSB0aGlzLmVsZW1IZWlnaHQ7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQuY3NzKCd0b3AnLCBhbmNob3JQdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fc2V0QnJlYWtQb2ludHMobmV3Q29udGFpbmVySGVpZ2h0LCBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChjYiAmJiB0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHsgY2IoKTsgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHVwcGVyIGFuZCBsb3dlciBicmVha3BvaW50cyBmb3IgdGhlIGVsZW1lbnQgdG8gYmVjb21lIHN0aWNreS91bnN0aWNreS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGVsZW1IZWlnaHQgLSBweCB2YWx1ZSBmb3Igc3RpY2t5LiRlbGVtZW50IGhlaWdodCwgY2FsY3VsYXRlZCBieSBgX3NldFNpemVzYC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gY29tcGxldGlvbi5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRCcmVha1BvaW50cyhlbGVtSGVpZ2h0LCBjYikge1xuICAgIGlmICghdGhpcy5jYW5TdGljaykge1xuICAgICAgaWYgKGNiICYmIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykgeyBjYigpOyB9XG4gICAgICBlbHNlIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgfVxuICAgIHZhciBtVG9wID0gZW1DYWxjKHRoaXMub3B0aW9ucy5tYXJnaW5Ub3ApLFxuICAgICAgICBtQnRtID0gZW1DYWxjKHRoaXMub3B0aW9ucy5tYXJnaW5Cb3R0b20pLFxuICAgICAgICB0b3BQb2ludCA9IHRoaXMucG9pbnRzID8gdGhpcy5wb2ludHNbMF0gOiB0aGlzLiRhbmNob3Iub2Zmc2V0KCkudG9wLFxuICAgICAgICBib3R0b21Qb2ludCA9IHRoaXMucG9pbnRzID8gdGhpcy5wb2ludHNbMV0gOiB0b3BQb2ludCArIHRoaXMuYW5jaG9ySGVpZ2h0LFxuICAgICAgICAvLyB0b3BQb2ludCA9IHRoaXMuJGFuY2hvci5vZmZzZXQoKS50b3AgfHwgdGhpcy5wb2ludHNbMF0sXG4gICAgICAgIC8vIGJvdHRvbVBvaW50ID0gdG9wUG9pbnQgKyB0aGlzLmFuY2hvckhlaWdodCB8fCB0aGlzLnBvaW50c1sxXSxcbiAgICAgICAgd2luSGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5zdGlja1RvID09PSAndG9wJykge1xuICAgICAgdG9wUG9pbnQgLT0gbVRvcDtcbiAgICAgIGJvdHRvbVBvaW50IC09IChlbGVtSGVpZ2h0ICsgbVRvcCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuc3RpY2tUbyA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHRvcFBvaW50IC09ICh3aW5IZWlnaHQgLSAoZWxlbUhlaWdodCArIG1CdG0pKTtcbiAgICAgIGJvdHRvbVBvaW50IC09ICh3aW5IZWlnaHQgLSBtQnRtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy90aGlzIHdvdWxkIGJlIHRoZSBzdGlja1RvOiBib3RoIG9wdGlvbi4uLiB0cmlja3lcbiAgICB9XG5cbiAgICB0aGlzLnRvcFBvaW50ID0gdG9wUG9pbnQ7XG4gICAgdGhpcy5ib3R0b21Qb2ludCA9IGJvdHRvbVBvaW50O1xuXG4gICAgaWYgKGNiICYmIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykgeyBjYigpOyB9XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIGN1cnJlbnQgc3RpY2t5IGVsZW1lbnQuXG4gICAqIFJlc2V0cyB0aGUgZWxlbWVudCB0byB0aGUgdG9wIHBvc2l0aW9uIGZpcnN0LlxuICAgKiBSZW1vdmVzIGV2ZW50IGxpc3RlbmVycywgSlMtYWRkZWQgY3NzIHByb3BlcnRpZXMgYW5kIGNsYXNzZXMsIGFuZCB1bndyYXBzIHRoZSAkZWxlbWVudCBpZiB0aGUgSlMgYWRkZWQgdGhlICRjb250YWluZXIuXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9yZW1vdmVTdGlja3kodHJ1ZSk7XG5cbiAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKGAke3RoaXMub3B0aW9ucy5zdGlja3lDbGFzc30gaXMtYW5jaG9yZWQgaXMtYXQtdG9wYClcbiAgICAgICAgICAgICAgICAgLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAnJyxcbiAgICAgICAgICAgICAgICAgICB0b3A6ICcnLFxuICAgICAgICAgICAgICAgICAgIGJvdHRvbTogJycsXG4gICAgICAgICAgICAgICAgICAgJ21heC13aWR0aCc6ICcnXG4gICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgIC5vZmYoJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInKTtcbiAgICBpZiAodGhpcy4kYW5jaG9yICYmIHRoaXMuJGFuY2hvci5sZW5ndGgpIHtcbiAgICAgIHRoaXMuJGFuY2hvci5vZmYoJ2NoYW5nZS56Zi5zdGlja3knKTtcbiAgICB9XG4gICAgJCh3aW5kb3cpLm9mZih0aGlzLnNjcm9sbExpc3RlbmVyKTtcblxuICAgIGlmICh0aGlzLndhc1dyYXBwZWQpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQudW53cmFwKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJGNvbnRhaW5lci5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuY29udGFpbmVyQ2xhc3MpXG4gICAgICAgICAgICAgICAgICAgICAuY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAnJ1xuICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTtcbiAgfVxufVxuXG5TdGlja3kuZGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBDdXN0b21pemFibGUgY29udGFpbmVyIHRlbXBsYXRlLiBBZGQgeW91ciBvd24gY2xhc3NlcyBmb3Igc3R5bGluZyBhbmQgc2l6aW5nLlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlICcmbHQ7ZGl2IGRhdGEtc3RpY2t5LWNvbnRhaW5lciBjbGFzcz1cInNtYWxsLTYgY29sdW1uc1wiJmd0OyZsdDsvZGl2Jmd0OydcbiAgICovXG4gIGNvbnRhaW5lcjogJzxkaXYgZGF0YS1zdGlja3ktY29udGFpbmVyPjwvZGl2PicsXG4gIC8qKlxuICAgKiBMb2NhdGlvbiBpbiB0aGUgdmlldyB0aGUgZWxlbWVudCBzdGlja3MgdG8uXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgJ3RvcCdcbiAgICovXG4gIHN0aWNrVG86ICd0b3AnLFxuICAvKipcbiAgICogSWYgYW5jaG9yZWQgdG8gYSBzaW5nbGUgZWxlbWVudCwgdGhlIGlkIG9mIHRoYXQgZWxlbWVudC5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAnZXhhbXBsZUlkJ1xuICAgKi9cbiAgYW5jaG9yOiAnJyxcbiAgLyoqXG4gICAqIElmIHVzaW5nIG1vcmUgdGhhbiBvbmUgZWxlbWVudCBhcyBhbmNob3IgcG9pbnRzLCB0aGUgaWQgb2YgdGhlIHRvcCBhbmNob3IuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgJ2V4YW1wbGVJZDp0b3AnXG4gICAqL1xuICB0b3BBbmNob3I6ICcnLFxuICAvKipcbiAgICogSWYgdXNpbmcgbW9yZSB0aGFuIG9uZSBlbGVtZW50IGFzIGFuY2hvciBwb2ludHMsIHRoZSBpZCBvZiB0aGUgYm90dG9tIGFuY2hvci5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAnZXhhbXBsZUlkOmJvdHRvbSdcbiAgICovXG4gIGJ0bUFuY2hvcjogJycsXG4gIC8qKlxuICAgKiBNYXJnaW4sIGluIGBlbWAncyB0byBhcHBseSB0byB0aGUgdG9wIG9mIHRoZSBlbGVtZW50IHdoZW4gaXQgYmVjb21lcyBzdGlja3kuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgMVxuICAgKi9cbiAgbWFyZ2luVG9wOiAxLFxuICAvKipcbiAgICogTWFyZ2luLCBpbiBgZW1gJ3MgdG8gYXBwbHkgdG8gdGhlIGJvdHRvbSBvZiB0aGUgZWxlbWVudCB3aGVuIGl0IGJlY29tZXMgc3RpY2t5LlxuICAgKiBAb3B0aW9uXG4gICAqIEBleGFtcGxlIDFcbiAgICovXG4gIG1hcmdpbkJvdHRvbTogMSxcbiAgLyoqXG4gICAqIEJyZWFrcG9pbnQgc3RyaW5nIHRoYXQgaXMgdGhlIG1pbmltdW0gc2NyZWVuIHNpemUgYW4gZWxlbWVudCBzaG91bGQgYmVjb21lIHN0aWNreS5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSAnbWVkaXVtJ1xuICAgKi9cbiAgc3RpY2t5T246ICdtZWRpdW0nLFxuICAvKipcbiAgICogQ2xhc3MgYXBwbGllZCB0byBzdGlja3kgZWxlbWVudCwgYW5kIHJlbW92ZWQgb24gZGVzdHJ1Y3Rpb24uIEZvdW5kYXRpb24gZGVmYXVsdHMgdG8gYHN0aWNreWAuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgJ3N0aWNreSdcbiAgICovXG4gIHN0aWNreUNsYXNzOiAnc3RpY2t5JyxcbiAgLyoqXG4gICAqIENsYXNzIGFwcGxpZWQgdG8gc3RpY2t5IGNvbnRhaW5lci4gRm91bmRhdGlvbiBkZWZhdWx0cyB0byBgc3RpY2t5LWNvbnRhaW5lcmAuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgJ3N0aWNreS1jb250YWluZXInXG4gICAqL1xuICBjb250YWluZXJDbGFzczogJ3N0aWNreS1jb250YWluZXInLFxuICAvKipcbiAgICogTnVtYmVyIG9mIHNjcm9sbCBldmVudHMgYmV0d2VlbiB0aGUgcGx1Z2luJ3MgcmVjYWxjdWxhdGluZyBzdGlja3kgcG9pbnRzLiBTZXR0aW5nIGl0IHRvIGAwYCB3aWxsIGNhdXNlIGl0IHRvIHJlY2FsYyBldmVyeSBzY3JvbGwgZXZlbnQsIHNldHRpbmcgaXQgdG8gYC0xYCB3aWxsIHByZXZlbnQgcmVjYWxjIG9uIHNjcm9sbC5cbiAgICogQG9wdGlvblxuICAgKiBAZXhhbXBsZSA1MFxuICAgKi9cbiAgY2hlY2tFdmVyeTogLTFcbn07XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGNhbGN1bGF0ZSBlbSB2YWx1ZXNcbiAqIEBwYXJhbSBOdW1iZXIge2VtfSAtIG51bWJlciBvZiBlbSdzIHRvIGNhbGN1bGF0ZSBpbnRvIHBpeGVsc1xuICovXG5mdW5jdGlvbiBlbUNhbGMoZW0pIHtcbiAgcmV0dXJuIHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmJvZHksIG51bGwpLmZvbnRTaXplLCAxMCkgKiBlbTtcbn1cblxuLy8gV2luZG93IGV4cG9ydHNcbkZvdW5kYXRpb24ucGx1Z2luKFN0aWNreSwgJ1N0aWNreScpO1xuXG59KGpRdWVyeSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2ZvdW5kYXRpb24tc2l0ZXMvanMvZm91bmRhdGlvbi5zdGlja3kuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n!function ($) {\n  // Default set of media queries\n  var defaultQueries = {\n    'default': 'only screen',\n    landscape: 'only screen and (orientation: landscape)',\n    portrait: 'only screen and (orientation: portrait)',\n    retina: 'only screen and (-webkit-min-device-pixel-ratio: 2),' + 'only screen and (min--moz-device-pixel-ratio: 2),' + 'only screen and (-o-min-device-pixel-ratio: 2/1),' + 'only screen and (min-device-pixel-ratio: 2),' + 'only screen and (min-resolution: 192dpi),' + 'only screen and (min-resolution: 2dppx)'\n  };\n  var MediaQuery = {\n    queries: [],\n    current: '',\n\n    /**\n     * Initializes the media query helper, by extracting the breakpoint list from the CSS and activating the breakpoint watcher.\n     * @function\n     * @private\n     */\n    _init: function _init() {\n      var self = this;\n      var extractedStyles = $('.foundation-mq').css('font-family');\n      var namedQueries;\n      namedQueries = parseStyleToObject(extractedStyles);\n\n      for (var key in namedQueries) {\n        if (namedQueries.hasOwnProperty(key)) {\n          self.queries.push({\n            name: key,\n            value: \"only screen and (min-width: \".concat(namedQueries[key], \")\")\n          });\n        }\n      }\n\n      this.current = this._getCurrentSize();\n\n      this._watcher();\n    },\n\n    /**\n     * Checks if the screen is at least as wide as a breakpoint.\n     * @function\n     * @param {String} size - Name of the breakpoint to check.\n     * @returns {Boolean} `true` if the breakpoint matches, `false` if it's smaller.\n     */\n    atLeast: function atLeast(size) {\n      var query = this.get(size);\n\n      if (query) {\n        return window.matchMedia(query).matches;\n      }\n\n      return false;\n    },\n\n    /**\n     * Gets the media query of a breakpoint.\n     * @function\n     * @param {String} size - Name of the breakpoint to get.\n     * @returns {String|null} - The media query of the breakpoint, or `null` if the breakpoint doesn't exist.\n     */\n    get: function get(size) {\n      for (var i in this.queries) {\n        if (this.queries.hasOwnProperty(i)) {\n          var query = this.queries[i];\n          if (size === query.name) return query.value;\n        }\n      }\n\n      return null;\n    },\n\n    /**\n     * Gets the current breakpoint name by testing every breakpoint and returning the last one to match (the biggest one).\n     * @function\n     * @private\n     * @returns {String} Name of the current breakpoint.\n     */\n    _getCurrentSize: function _getCurrentSize() {\n      var matched;\n\n      for (var i = 0; i < this.queries.length; i++) {\n        var query = this.queries[i];\n\n        if (window.matchMedia(query.value).matches) {\n          matched = query;\n        }\n      }\n\n      if (_typeof(matched) === 'object') {\n        return matched.name;\n      } else {\n        return matched;\n      }\n    },\n\n    /**\n     * Activates the breakpoint watcher, which fires an event on the window whenever the breakpoint changes.\n     * @function\n     * @private\n     */\n    _watcher: function _watcher() {\n      var _this = this;\n\n      $(window).on('resize.zf.mediaquery', function () {\n        var newSize = _this._getCurrentSize(),\n            currentSize = _this.current;\n\n        if (newSize !== currentSize) {\n          // Change the current media query\n          _this.current = newSize; // Broadcast the media query change on the window\n\n          $(window).trigger('changed.zf.mediaquery', [newSize, currentSize]);\n        }\n      });\n    }\n  };\n  Foundation.MediaQuery = MediaQuery; // matchMedia() polyfill - Test a CSS media type/query in JS.\n  // Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. Dual MIT/BSD license\n\n  window.matchMedia || (window.matchMedia = function () {\n    'use strict'; // For browsers that support matchMedium api such as IE 9 and webkit\n\n    var styleMedia = window.styleMedia || window.media; // For those that don't support matchMedium\n\n    if (!styleMedia) {\n      var style = document.createElement('style'),\n          script = document.getElementsByTagName('script')[0],\n          info = null;\n      style.type = 'text/css';\n      style.id = 'matchmediajs-test';\n      script && script.parentNode && script.parentNode.insertBefore(style, script); // 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers\n\n      info = 'getComputedStyle' in window && window.getComputedStyle(style, null) || style.currentStyle;\n      styleMedia = {\n        matchMedium: function matchMedium(media) {\n          var text = \"@media \".concat(media, \"{ #matchmediajs-test { width: 1px; } }\"); // 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers\n\n          if (style.styleSheet) {\n            style.styleSheet.cssText = text;\n          } else {\n            style.textContent = text;\n          } // Test if media query is true or false\n\n\n          return info.width === '1px';\n        }\n      };\n    }\n\n    return function (media) {\n      return {\n        matches: styleMedia.matchMedium(media || 'all'),\n        media: media || 'all'\n      };\n    };\n  }()); // Thank you: https://github.com/sindresorhus/query-string\n\n  function parseStyleToObject(str) {\n    var styleObject = {};\n\n    if (typeof str !== 'string') {\n      return styleObject;\n    }\n\n    str = str.trim().slice(1, -1); // browsers re-quote string style values\n\n    if (!str) {\n      return styleObject;\n    }\n\n    styleObject = str.split('&').reduce(function (ret, param) {\n      var parts = param.replace(/\\+/g, ' ').split('=');\n      var key = parts[0];\n      var val = parts[1];\n      key = decodeURIComponent(key); // missing `=` should be `null`:\n      // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\n\n      val = val === undefined ? null : decodeURIComponent(val);\n\n      if (!ret.hasOwnProperty(key)) {\n        ret[key] = val;\n      } else if (Array.isArray(ret[key])) {\n        ret[key].push(val);\n      } else {\n        ret[key] = [ret[key], val];\n      }\n\n      return ret;\n    }, {});\n    return styleObject;\n  }\n\n  Foundation.MediaQuery = MediaQuery;\n}(jQuery);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2ZvdW5kYXRpb24tc2l0ZXMvanMvZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnkuanM/Njk4NSJdLCJuYW1lcyI6WyIkIiwiZGVmYXVsdFF1ZXJpZXMiLCJsYW5kc2NhcGUiLCJwb3J0cmFpdCIsInJldGluYSIsIk1lZGlhUXVlcnkiLCJxdWVyaWVzIiwiY3VycmVudCIsIl9pbml0Iiwic2VsZiIsImV4dHJhY3RlZFN0eWxlcyIsImNzcyIsIm5hbWVkUXVlcmllcyIsInBhcnNlU3R5bGVUb09iamVjdCIsImtleSIsImhhc093blByb3BlcnR5IiwicHVzaCIsIm5hbWUiLCJ2YWx1ZSIsIl9nZXRDdXJyZW50U2l6ZSIsIl93YXRjaGVyIiwiYXRMZWFzdCIsInNpemUiLCJxdWVyeSIsImdldCIsIndpbmRvdyIsIm1hdGNoTWVkaWEiLCJtYXRjaGVzIiwiaSIsIm1hdGNoZWQiLCJsZW5ndGgiLCJvbiIsIm5ld1NpemUiLCJjdXJyZW50U2l6ZSIsInRyaWdnZXIiLCJGb3VuZGF0aW9uIiwic3R5bGVNZWRpYSIsIm1lZGlhIiwic3R5bGUiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJzY3JpcHQiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImluZm8iLCJ0eXBlIiwiaWQiLCJwYXJlbnROb2RlIiwiaW5zZXJ0QmVmb3JlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImN1cnJlbnRTdHlsZSIsIm1hdGNoTWVkaXVtIiwidGV4dCIsInN0eWxlU2hlZXQiLCJjc3NUZXh0IiwidGV4dENvbnRlbnQiLCJ3aWR0aCIsInN0ciIsInN0eWxlT2JqZWN0IiwidHJpbSIsInNsaWNlIiwic3BsaXQiLCJyZWR1Y2UiLCJyZXQiLCJwYXJhbSIsInBhcnRzIiwicmVwbGFjZSIsInZhbCIsImRlY29kZVVSSUNvbXBvbmVudCIsInVuZGVmaW5lZCIsIkFycmF5IiwiaXNBcnJheSIsImpRdWVyeSJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7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cUIsR0FBckIsRUFBMEJMLEtBQTFCLENBQWdDLEdBQWhDLENBQVo7QUFDQSxVQUFJOUMsR0FBRyxHQUFHa0QsS0FBSyxDQUFDLENBQUQsQ0FBZjtBQUNBLFVBQUlFLEdBQUcsR0FBR0YsS0FBSyxDQUFDLENBQUQsQ0FBZjtBQUNBbEQsU0FBRyxHQUFHcUQsa0JBQWtCLENBQUNyRCxHQUFELENBQXhCLENBSnVELENBTXZEO0FBQ0E7O0FBQ0FvRCxTQUFHLEdBQUdBLEdBQUcsS0FBS0UsU0FBUixHQUFvQixJQUFwQixHQUEyQkQsa0JBQWtCLENBQUNELEdBQUQsQ0FBbkQ7O0FBRUEsVUFBSSxDQUFDSixHQUFHLENBQUMvQyxjQUFKLENBQW1CRCxHQUFuQixDQUFMLEVBQThCO0FBQzVCZ0QsV0FBRyxDQUFDaEQsR0FBRCxDQUFILEdBQVdvRCxHQUFYO0FBQ0QsT0FGRCxNQUVPLElBQUlHLEtBQUssQ0FBQ0MsT0FBTixDQUFjUixHQUFHLENBQUNoRCxHQUFELENBQWpCLENBQUosRUFBNkI7QUFDbENnRCxXQUFHLENBQUNoRCxHQUFELENBQUgsQ0FBU0UsSUFBVCxDQUFja0QsR0FBZDtBQUNELE9BRk0sTUFFQTtBQUNMSixXQUFHLENBQUNoRCxHQUFELENBQUgsR0FBVyxDQUFDZ0QsR0FBRyxDQUFDaEQsR0FBRCxDQUFKLEVBQVdvRCxHQUFYLENBQVg7QUFDRDs7QUFDRCxhQUFPSixHQUFQO0FBQ0QsS0FsQmEsRUFrQlgsRUFsQlcsQ0FBZDtBQW9CQSxXQUFPTCxXQUFQO0FBQ0Q7O0FBRUR0QixZQUFVLENBQUM5QixVQUFYLEdBQXdCQSxVQUF4QjtBQUVDLENBbk5BLENBbU5Da0UsTUFuTkQsQ0FBRCIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4hZnVuY3Rpb24oJCkge1xuXG4vLyBEZWZhdWx0IHNldCBvZiBtZWRpYSBxdWVyaWVzXG5jb25zdCBkZWZhdWx0UXVlcmllcyA9IHtcbiAgJ2RlZmF1bHQnIDogJ29ubHkgc2NyZWVuJyxcbiAgbGFuZHNjYXBlIDogJ29ubHkgc2NyZWVuIGFuZCAob3JpZW50YXRpb246IGxhbmRzY2FwZSknLFxuICBwb3J0cmFpdCA6ICdvbmx5IHNjcmVlbiBhbmQgKG9yaWVudGF0aW9uOiBwb3J0cmFpdCknLFxuICByZXRpbmEgOiAnb25seSBzY3JlZW4gYW5kICgtd2Via2l0LW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDIpLCcgK1xuICAgICdvbmx5IHNjcmVlbiBhbmQgKG1pbi0tbW96LWRldmljZS1waXhlbC1yYXRpbzogMiksJyArXG4gICAgJ29ubHkgc2NyZWVuIGFuZCAoLW8tbWluLWRldmljZS1waXhlbC1yYXRpbzogMi8xKSwnICtcbiAgICAnb25seSBzY3JlZW4gYW5kIChtaW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAyKSwnICtcbiAgICAnb25seSBzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogMTkyZHBpKSwnICtcbiAgICAnb25seSBzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogMmRwcHgpJ1xufTtcblxudmFyIE1lZGlhUXVlcnkgPSB7XG4gIHF1ZXJpZXM6IFtdLFxuXG4gIGN1cnJlbnQ6ICcnLFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgbWVkaWEgcXVlcnkgaGVscGVyLCBieSBleHRyYWN0aW5nIHRoZSBicmVha3BvaW50IGxpc3QgZnJvbSB0aGUgQ1NTIGFuZCBhY3RpdmF0aW5nIHRoZSBicmVha3BvaW50IHdhdGNoZXIuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXQoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBleHRyYWN0ZWRTdHlsZXMgPSAkKCcuZm91bmRhdGlvbi1tcScpLmNzcygnZm9udC1mYW1pbHknKTtcbiAgICB2YXIgbmFtZWRRdWVyaWVzO1xuXG4gICAgbmFtZWRRdWVyaWVzID0gcGFyc2VTdHlsZVRvT2JqZWN0KGV4dHJhY3RlZFN0eWxlcyk7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gbmFtZWRRdWVyaWVzKSB7XG4gICAgICBpZihuYW1lZFF1ZXJpZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBzZWxmLnF1ZXJpZXMucHVzaCh7XG4gICAgICAgICAgbmFtZToga2V5LFxuICAgICAgICAgIHZhbHVlOiBgb25seSBzY3JlZW4gYW5kIChtaW4td2lkdGg6ICR7bmFtZWRRdWVyaWVzW2tleV19KWBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50ID0gdGhpcy5fZ2V0Q3VycmVudFNpemUoKTtcblxuICAgIHRoaXMuX3dhdGNoZXIoKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBzY3JlZW4gaXMgYXQgbGVhc3QgYXMgd2lkZSBhcyBhIGJyZWFrcG9pbnQuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2l6ZSAtIE5hbWUgb2YgdGhlIGJyZWFrcG9pbnQgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGJyZWFrcG9pbnQgbWF0Y2hlcywgYGZhbHNlYCBpZiBpdCdzIHNtYWxsZXIuXG4gICAqL1xuICBhdExlYXN0KHNpemUpIHtcbiAgICB2YXIgcXVlcnkgPSB0aGlzLmdldChzaXplKTtcblxuICAgIGlmIChxdWVyeSkge1xuICAgICAgcmV0dXJuIHdpbmRvdy5tYXRjaE1lZGlhKHF1ZXJ5KS5tYXRjaGVzO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB0aGUgbWVkaWEgcXVlcnkgb2YgYSBicmVha3BvaW50LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHNpemUgLSBOYW1lIG9mIHRoZSBicmVha3BvaW50IHRvIGdldC5cbiAgICogQHJldHVybnMge1N0cmluZ3xudWxsfSAtIFRoZSBtZWRpYSBxdWVyeSBvZiB0aGUgYnJlYWtwb2ludCwgb3IgYG51bGxgIGlmIHRoZSBicmVha3BvaW50IGRvZXNuJ3QgZXhpc3QuXG4gICAqL1xuICBnZXQoc2l6ZSkge1xuICAgIGZvciAodmFyIGkgaW4gdGhpcy5xdWVyaWVzKSB7XG4gICAgICBpZih0aGlzLnF1ZXJpZXMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyaWVzW2ldO1xuICAgICAgICBpZiAoc2l6ZSA9PT0gcXVlcnkubmFtZSkgcmV0dXJuIHF1ZXJ5LnZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IGJyZWFrcG9pbnQgbmFtZSBieSB0ZXN0aW5nIGV2ZXJ5IGJyZWFrcG9pbnQgYW5kIHJldHVybmluZyB0aGUgbGFzdCBvbmUgdG8gbWF0Y2ggKHRoZSBiaWdnZXN0IG9uZSkuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBOYW1lIG9mIHRoZSBjdXJyZW50IGJyZWFrcG9pbnQuXG4gICAqL1xuICBfZ2V0Q3VycmVudFNpemUoKSB7XG4gICAgdmFyIG1hdGNoZWQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucXVlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyaWVzW2ldO1xuXG4gICAgICBpZiAod2luZG93Lm1hdGNoTWVkaWEocXVlcnkudmFsdWUpLm1hdGNoZXMpIHtcbiAgICAgICAgbWF0Y2hlZCA9IHF1ZXJ5O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbWF0Y2hlZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBtYXRjaGVkLm5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtYXRjaGVkO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWN0aXZhdGVzIHRoZSBicmVha3BvaW50IHdhdGNoZXIsIHdoaWNoIGZpcmVzIGFuIGV2ZW50IG9uIHRoZSB3aW5kb3cgd2hlbmV2ZXIgdGhlIGJyZWFrcG9pbnQgY2hhbmdlcy5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfd2F0Y2hlcigpIHtcbiAgICAkKHdpbmRvdykub24oJ3Jlc2l6ZS56Zi5tZWRpYXF1ZXJ5JywgKCkgPT4ge1xuICAgICAgdmFyIG5ld1NpemUgPSB0aGlzLl9nZXRDdXJyZW50U2l6ZSgpLCBjdXJyZW50U2l6ZSA9IHRoaXMuY3VycmVudDtcblxuICAgICAgaWYgKG5ld1NpemUgIT09IGN1cnJlbnRTaXplKSB7XG4gICAgICAgIC8vIENoYW5nZSB0aGUgY3VycmVudCBtZWRpYSBxdWVyeVxuICAgICAgICB0aGlzLmN1cnJlbnQgPSBuZXdTaXplO1xuXG4gICAgICAgIC8vIEJyb2FkY2FzdCB0aGUgbWVkaWEgcXVlcnkgY2hhbmdlIG9uIHRoZSB3aW5kb3dcbiAgICAgICAgJCh3aW5kb3cpLnRyaWdnZXIoJ2NoYW5nZWQuemYubWVkaWFxdWVyeScsIFtuZXdTaXplLCBjdXJyZW50U2l6ZV0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG5Gb3VuZGF0aW9uLk1lZGlhUXVlcnkgPSBNZWRpYVF1ZXJ5O1xuXG4vLyBtYXRjaE1lZGlhKCkgcG9seWZpbGwgLSBUZXN0IGEgQ1NTIG1lZGlhIHR5cGUvcXVlcnkgaW4gSlMuXG4vLyBBdXRob3JzICYgY29weXJpZ2h0IChjKSAyMDEyOiBTY290dCBKZWhsLCBQYXVsIElyaXNoLCBOaWNob2xhcyBaYWthcywgRGF2aWQgS25pZ2h0LiBEdWFsIE1JVC9CU0QgbGljZW5zZVxud2luZG93Lm1hdGNoTWVkaWEgfHwgKHdpbmRvdy5tYXRjaE1lZGlhID0gZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBGb3IgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IG1hdGNoTWVkaXVtIGFwaSBzdWNoIGFzIElFIDkgYW5kIHdlYmtpdFxuICB2YXIgc3R5bGVNZWRpYSA9ICh3aW5kb3cuc3R5bGVNZWRpYSB8fCB3aW5kb3cubWVkaWEpO1xuXG4gIC8vIEZvciB0aG9zZSB0aGF0IGRvbid0IHN1cHBvcnQgbWF0Y2hNZWRpdW1cbiAgaWYgKCFzdHlsZU1lZGlhKSB7XG4gICAgdmFyIHN0eWxlICAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpLFxuICAgIHNjcmlwdCAgICAgID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpWzBdLFxuICAgIGluZm8gICAgICAgID0gbnVsbDtcblxuICAgIHN0eWxlLnR5cGUgID0gJ3RleHQvY3NzJztcbiAgICBzdHlsZS5pZCAgICA9ICdtYXRjaG1lZGlhanMtdGVzdCc7XG5cbiAgICBzY3JpcHQgJiYgc2NyaXB0LnBhcmVudE5vZGUgJiYgc2NyaXB0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHN0eWxlLCBzY3JpcHQpO1xuXG4gICAgLy8gJ3N0eWxlLmN1cnJlbnRTdHlsZScgaXMgdXNlZCBieSBJRSA8PSA4IGFuZCAnd2luZG93LmdldENvbXB1dGVkU3R5bGUnIGZvciBhbGwgb3RoZXIgYnJvd3NlcnNcbiAgICBpbmZvID0gKCdnZXRDb21wdXRlZFN0eWxlJyBpbiB3aW5kb3cpICYmIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHN0eWxlLCBudWxsKSB8fCBzdHlsZS5jdXJyZW50U3R5bGU7XG5cbiAgICBzdHlsZU1lZGlhID0ge1xuICAgICAgbWF0Y2hNZWRpdW0obWVkaWEpIHtcbiAgICAgICAgdmFyIHRleHQgPSBgQG1lZGlhICR7bWVkaWF9eyAjbWF0Y2htZWRpYWpzLXRlc3QgeyB3aWR0aDogMXB4OyB9IH1gO1xuXG4gICAgICAgIC8vICdzdHlsZS5zdHlsZVNoZWV0JyBpcyB1c2VkIGJ5IElFIDw9IDggYW5kICdzdHlsZS50ZXh0Q29udGVudCcgZm9yIGFsbCBvdGhlciBicm93c2Vyc1xuICAgICAgICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgICAgICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHRleHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGVzdCBpZiBtZWRpYSBxdWVyeSBpcyB0cnVlIG9yIGZhbHNlXG4gICAgICAgIHJldHVybiBpbmZvLndpZHRoID09PSAnMXB4JztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24obWVkaWEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWF0Y2hlczogc3R5bGVNZWRpYS5tYXRjaE1lZGl1bShtZWRpYSB8fCAnYWxsJyksXG4gICAgICBtZWRpYTogbWVkaWEgfHwgJ2FsbCdcbiAgICB9O1xuICB9XG59KCkpO1xuXG4vLyBUaGFuayB5b3U6IGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvcXVlcnktc3RyaW5nXG5mdW5jdGlvbiBwYXJzZVN0eWxlVG9PYmplY3Qoc3RyKSB7XG4gIHZhciBzdHlsZU9iamVjdCA9IHt9O1xuXG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzdHlsZU9iamVjdDtcbiAgfVxuXG4gIHN0ciA9IHN0ci50cmltKCkuc2xpY2UoMSwgLTEpOyAvLyBicm93c2VycyByZS1xdW90ZSBzdHJpbmcgc3R5bGUgdmFsdWVzXG5cbiAgaWYgKCFzdHIpIHtcbiAgICByZXR1cm4gc3R5bGVPYmplY3Q7XG4gIH1cblxuICBzdHlsZU9iamVjdCA9IHN0ci5zcGxpdCgnJicpLnJlZHVjZShmdW5jdGlvbihyZXQsIHBhcmFtKSB7XG4gICAgdmFyIHBhcnRzID0gcGFyYW0ucmVwbGFjZSgvXFwrL2csICcgJykuc3BsaXQoJz0nKTtcbiAgICB2YXIga2V5ID0gcGFydHNbMF07XG4gICAgdmFyIHZhbCA9IHBhcnRzWzFdO1xuICAgIGtleSA9IGRlY29kZVVSSUNvbXBvbmVudChrZXkpO1xuXG4gICAgLy8gbWlzc2luZyBgPWAgc2hvdWxkIGJlIGBudWxsYDpcbiAgICAvLyBodHRwOi8vdzMub3JnL1RSLzIwMTIvV0QtdXJsLTIwMTIwNTI0LyNjb2xsZWN0LXVybC1wYXJhbWV0ZXJzXG4gICAgdmFsID0gdmFsID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVjb2RlVVJJQ29tcG9uZW50KHZhbCk7XG5cbiAgICBpZiAoIXJldC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICByZXRba2V5XSA9IHZhbDtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmV0W2tleV0pKSB7XG4gICAgICByZXRba2V5XS5wdXNoKHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldFtrZXldID0gW3JldFtrZXldLCB2YWxdO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9LCB7fSk7XG5cbiAgcmV0dXJuIHN0eWxlT2JqZWN0O1xufVxuXG5Gb3VuZGF0aW9uLk1lZGlhUXVlcnkgPSBNZWRpYVF1ZXJ5O1xuXG59KGpRdWVyeSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ib3dlcl9jb21wb25lbnRzL2ZvdW5kYXRpb24tc2l0ZXMvanMvZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnkuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(0);
__webpack_require__(3);
__webpack_require__(2);
module.exports = __webpack_require__(1);


/***/ })
/******/ ]);